class ycl_pm_planner_class definition
  public
  final
  create public .

  public section.

    interfaces /neptune/if_nad_server .

    types:
      begin of  ty_notilist,
        qmnum         type qmel-qmnum,
        qmart         type qmel-qmart,
        qmtxt         type qmel-qmtxt,
        priok         type qmel-priok,
        erdat         type qmel-erdat,
        aufnr         type qmel-aufnr,
        objnr         type qmel-objnr,
        stat          type bsvx-sttxt,
        tplnr         type string,
        equnr         type qmel-shn_equipment,
        floc_text     type string,
        equi_text     type string,
        usrstatus     type string,
        search        type string,
        stat_text     type string,
        stat_color    type string,
        keyfield      type string,
        offline       type string,
        offline_icon  type string,
        offline_state type string,
        offline_text  type string,
        notistat      type string,
      end of ty_notilist .
    types:
      begin of ty_worklist,
        aufnr         type aufk-aufnr,
        erdat         type aufk-erdat,
        ktext         type aufk-ktext,
        vaplz         type aufk-vaplz,
        phas0         type aufk-phas0,
        phas1         type aufk-phas1,
        objnr1        type aufk-objnr,
        gstrp         type afko-gstrp,
        aufpl         type afvc-aufpl,
        aplzl         type afvc-aplzl,
        vornr         type afvc-vornr,
        ltxa1         type afvc-ltxa1,
        arbid         type afvc-arbid,
        objnr         type afvc-objnr,
        plan          type string,
        oroper        type string,
        keyfield      type string,
        status        type string,
        icon          type string,
        color         type string,
        offline       type string,
        offline_icon  type string,
        offline_state type string,
        offline_text  type string,
      end of ty_worklist .
    types:
      begin of ty_work ,
        arbpl    type arbpl,
        cr_objty type cr_objty,
        cr_objid type cr_objid,
        werks    type crhd-werks,
        cr_ktext type cr_ktext,
        text     type string,
        keyfield type string,
      end of ty_work .
    types:
      begin of ty_ord_detail,
        aufnr      type afko-aufnr,
        gltrp      type afko-gltrp,
        gstrp      type afko-gstrp,
        gsuzp      type afko-gsuzp,
        gluzp      type afko-gluzp,
        auart      type aufart,
        erdat      type aufk-erdat,
        werks      type aufk-werks,
        user4      type aufk-user4,
        objnr      type aufk-objnr,
        vaplz      type aufk-vaplz,
        waers      type aufk-waers,
        phas0      type aufk-phas0,
        phas1      type aufk-phas1,
        ktext      type aufk-ktext,
        priok      type afih-priok,
        iloan      type afih-iloan,
        equnr      type afih-equnr,
        ilart      type afih-ilart,
        revnr      type afih-revnr,
        ingpr      type afih-ingpr,
        ingpr_text type char40,
        rel        type char1,
        tplnr      type string, "afvc-tplnr,
        costs      type string, "***
        long_text  type string,
        avt_type   type string, "***
        status     type string,
        icon       type string,
        color      type string,
        cklt       type boolean,
        oprc       type boolean,
        detc       type boolean,
        progress   type string,
        steus      type crhd-steus,
        prcnt      type /emn/dec5_2_v,
        act_detail type t353i_t-ilatx,
        loc_detail type iflotx-pltxt,
        rev_text   type string,
        pri_text   type string,
        equi_text  type string,
        keyfield   type string,
        uuid       type string,
        offline    type string,
        ikostenkgr type pmco_kgr-ikostenkgr,
      end of ty_ord_detail .
    types:
      begin of ty_noti_detail,
        qmnum      type qmel-qmnum,
        aufnr      type qmel-aufnr,
        qmart      type qmel-qmart,
        priok      type qmel-priok,
        qmtxt      type qmel-qmtxt,
        arbpl      type qmel-arbpl,
        ingrp      type qmih-ingrp,
        arbplwerk  type qmel-arbplwerk,
        qmartx     type tq80_t-qmartx,
        lg_text_n  type string,
        vaplz      type aufk-vaplz,
        arbpl2     type crhd-arbpl,
        objnr      type qmel-objnr,
        ingrp_text type t024i-innam,
        arbpl2_txt type string,
        floc_text  type string,
        equi_text  type string,
        pri_text   type string,
        keyfield   type string,
        usrstatus  type string,
        auart      type aufk-auart,
        ilart      type caufvd-ilart,
        tplnr      type string, "qmel-shn_funct_loc,
        equnr      type qmel-shn_equipment,
        chng(1)    type c,
      end of ty_noti_detail .
    types:
      begin of ty_tj30t,
        estat type j_estat,
        txt04 type j_txt04,
        txt30 type j_txt30,
        qmnum type qmnum,
      end of ty_tj30t .
    types:
      begin of ty_tj30,
        estat type  tj30-estat,
        txt04 type  tj30t-txt04,
        txt30 type  tj30t-txt30,
      end of ty_tj30 .
    types:
*            include type tj30t.
*    types : qmnum type qmel-qmnum.
*    types:   end of ty_tj30t .
      begin of ty_maint_checklist,
        wo_num          type aufk-aufnr, "Work Order Number
        desc            type string,
        hot_work        type boolean, "Hot Work
        confd_space     type boolean, "Confined Space
        other           type boolean, "Other
        safety_haz      type string, "Safety Hazards
        wh_tie_app      type boolean, "Tie-off Point Approved
        wh_tieneed_app  type boolean, "Tie-Off Point Needing Approval
        wh_scaffold_req type boolean, "Scaffold Required
        wh_scissor_lift type boolean, "Scissor Lift
        wh_ladder       type boolean, "Ladder
        wh_other        type boolean, "Other
        spc_tool_needed type string, "Special Tools Needed
        parts_req       type string, "Parts Required
        equip_info      type string, "Equipemnt Information
        ar_crane        type boolean, "Crane
        ar_hp_rig       type boolean, "HP Rig
        ar_res_cont     type boolean, "Resident Contractor
        ar_flex         type boolean, "Flex
        cs_fire_watch   type boolean, "fire_watch
        cs_hole_watch   type boolean, "hole_watch
        cs_insulation   type boolean, "Insulation
        cs_scaffold     type boolean, "Scaffold,
        cs_abate        type boolean, "abatement
        moc             type boolean,
        keyfield        type string,
      end of ty_maint_checklist .
    types:
*Added Strutures for work center and date ranges
      begin of ty_arbpl,
        arbpl type qmel-arbpl,
      end of ty_arbpl .
    types:
      begin of ty_priority,
        priok    type t356_t-priok,
        priokx   type t356_t-priokx,
        pri_text type string,
        keyfield type string,
      end of ty_priority .
    types:
      begin of ty_noti_types,
        qmart    type tq80-qmart,
        qmartx   type tq80_t-qmartx,
        keyfield type string,
      end of ty_noti_types .
    types:
      begin of ty_location,
        tplnr    type ilom_strno,
        pltxt    type iflotx-pltxt,
        keyfield type string,
      end of ty_location .
    types:
      begin of ty_equipment,
        equnr    type equi-equnr,
        eqktx    type eqkt-eqktx,
        keyfield type string,
      end of ty_equipment .
    types:
      begin of ty_act_type,
        auart    type t350i-auart,
        ilart    type t353i_t-ilart,
        ilatx    type t353i_t-ilatx,
        keyfield type string,
      end of ty_act_type .
    types:
      begin of ty_afvc,
        aufnr      type afko-aufnr,
        aufpl      type afvc-aufpl,
        aplzl      type afvc-aplzl,
        vornr      type afvc-vornr,
        arbid      type afvc-arbid,
        ltxa1      type afvc-ltxa1,
        steus      type afvc-steus,
        objnr      type afvc-objnr,
        tplnr      type string, "afvc-tplnr,
        equnr      type afvc-equnr,
        anzzl      type afvc-anzzl,
        matkl      type afvc-matkl,
        ekorg      type afvc-ekorg,
        ekgrp      type afvc-ekgrp,
        afnam      type afvc-afnam,
        wempf      type afvc-wempf,
        lifnr      type afvc-lifnr,
        ablad      type afvc-ablad,
        bednr      type afvc-bednr,
        plnnr      type afvc-plnnr,
        arbpl      type crhd-arbpl,
        status     type bsvx-sttxt,
        usrst      type bsvx-sttxt,
        arbei      type afvv-arbei,
        arbeh      type afvv-arbeh,
        ismnw      type afvv-ismnw,
        dauno      type afvv-dauno,
        usr00      type afvu-usr00,
        usr01      type afvu-usr01,
        usr02      type afvu-usr02,
        usr09      type char10, "afvu-usr09,
        anlzu      type afvc-anlzu,
        sakto      type afvgd-sakto,
        packno     type afvc-packno,
        commitment type esuh-commitment,
        sumlimit   type esuh-sumlimit,
        esth       type boolean,
        prto       type boolean,
        jbpk       type boolean,
        detc       type boolean,
        npln       type boolean,
        color      type string,
        text_oper  type string,
        text       type string,
        ind        type i,
        chng(2)    type c,
        lng_text   type boolean,
        keyfield   type string,
        werks      type werks_d,
        del_vis    type boolean,
        uuid       type string,
        selected   type string,
        ktsch      type string,
      end of ty_afvc .
    types:
      begin of ty_afvv,
        aufpl    type afvv-aufpl,
        aplzl    type afvv-aplzl,
        arbei    type afvv-arbei,
        arbeh    type afvv-arbeh,
        ismnw    type afvv-ismnw,
        dauno    type afvv-dauno,
        keyfield type string,
      end of ty_afvv .
    types:
      begin of ty_afvu,
        aufpl    type afvu-aufpl,
        aplzl    type afvu-aplzl,
        usr00    type afvu-usr00,
        usr01    type afvu-usr01,
        usr02    type afvu-usr02,
        usr09    type afvu-usr09,
        keyfield type string,
      end of ty_afvu .
    types:
      begin of ty_resb,
        aufnr           type resb-aufnr,
        rsnum           type resb-rsnum,
        rspos           type resb-rspos,
        matnr           type resb-matnr,
        werks           type resb-werks,
        bdmng           type resb-bdmng,
        meins           type resb-meins,
        enmng           type resb-enmng,
        postp           type resb-postp,
        posnr           type resb-posnr,
        potx1           type resb-potx1,
        vornr           type resb-vornr,
        ekgrp           type resb-ekgrp,
        matkl           type resb-matkl,
        bdter           type resb-bdter,
        afnam           type resbd-afnam,
        ekorg           type resbd-ekorg,
        gpreis          type resbd-gpreis,
        idnlf           type resbd-idnlf,
        flief           type resbd-flief,
        lifnr           type resbd-lifnr,
        saknr           type resbd-saknr,
        wempf           type resbd-wempf,
        ablad           type resbd-ablad,
        waers           type resbd-waers,
        catalogid       type resbd-catalogid,
        catalog_prod_id type resbd-catalog_prod_id,
        edit_visibilty  type boolean,
        del_visibility  type boolean,
        lng_text        type boolean,
        text            type string,
        ptext           type pttxt,
        status          type string,
        keyfield        type string,
        uuid            type string,
        gendate         type string,
        chng(1)         type c,
        incomplete_icon type string,
        incomplete_msg  type string,
        incomplete_clr  type string,
      end of ty_resb .
    types:
      begin of ty_attachment,
        work_order        type aufnr,
        keyfield          type string,
        icon              type string,
        icon_color        type string,
        file_name         type string,
        extension         type string,
        mime_type         type string,
        origin_type       type string,
        instid_b          type string,
        file_data         type string,
        available_offline type string,
        sort_group        type numc01,
        operation         type vornr,
        uuid              type string,
        gendate           type string,
        vornr             type afvc-vornr,
        del_vis           type boolean,
        sel_ind           type boolean,
      end of ty_attachment .
    types:
      begin of ty_attachment_data,
        instid_b  type string,
        file_data type string,
        keyfield  type string,
      end of ty_attachment_data .
    types:
      begin of ty_tapl,
        plnty    type plpo-plnty,
        plnnr    type plpo-plnnr,
        plnal    type plko-plnal,
        zaehl    type plpo-zaehl,
        datuv    type plpo-datuv,
        arbid    type plpo-arbid,
        ltxa1    type plko-ktext,
        dauno    type plpo-dauno,
        arbei    type plpo-arbei,
        anzzl    type plpo-anzzl,
        keyfield type string,
        aufnr    type aufk-aufnr,
        arbpl    type crhd-arbpl,
      end of ty_tapl .
    types:
      begin of ty_afab,
        aufnr       type aufk-aufnr,
        aufpl_vor   type afab-aufpl_vor,
        aplzl_vornr type afab-aplzl_vor,
        aplzl_vor   type afvc-vornr,
        aufpl_nch   type afab-aufpl_nch,
        aplzl_nch   type afvc-vornr,
        aobar       type afab-aobar,
        predecessor type afvc-vornr,
        successor   type afvc-vornr,
        chng        type char1,
        keyfield    type string,
        vornc       type afab-vornc,
        ncvor       type afab-ncvor,
        opertxt     type ltxa1,
        arbpl       type arbpl,
        text        type string,
        uuid        type string,
        gendate     type string,
      end of ty_afab .
    types:
      begin of ty_pmco,
        aufnr      type aufk-aufnr,
        acpos      type pmco-acpos,
        ktext      type tpir2t-ktext,
        skostenkgr type dkgrkossch,
        pkostenkgr type dkgrkoplan,
        ikostenkgr type dkgrkosist,
        waers      type waers,
        chng       type char1,
        keyfield   type string,
        edit       type boolean,
      end of ty_pmco .
    types:
      begin of ty_messages,
        message  type string,
        mss_type type string,
        value    type string,
      end of ty_messages .
    types:
      begin of ty_struct,
        work_order    type aufnr,
        node_id       type string,
        parent_id     type string,
        iscontainer   type ddbool_d,
        text          type string,
        expanded      type ddbool_d,
        selectable    type ddbool_d,
        icon          type string,
        highlight     type string,
        object_number type char40,
        maktx         type makt-maktx,
        meins         type mara-meins,
        keyfield      type string,
        bklas         type mbew-bklas,
      end of ty_struct .
    types:
      begin of ty_search_tasks,
        werks    type werks_d,
        arbpl    type crhd-arbpl,
        erdat    type aufk-erdat,
        verwe    type plko-verwe,
        ktext    type plko-ktext,
        istru    type  plko-istru,
        vagrp    type plko-vagrp,
        keyfield type string,
      end of ty_search_tasks .
    types:
      begin of ty_order,
        keyfield type string,
      end of ty_order .
    types:
      begin of ty_plko,
        plnty    type plko-plnty,
        plnnr    type plko-plnnr,
        plnal    type plko-plnal,
        zaehl    type plko-zaehl,
        datuv    type plko-datuv,
        verwe    type plko-verwe,
        werks    type plko-werks,
        statu    type plko-statu,
        vagrp    type plko-vagrp,
        ktext    type plko-ktext,
        txtsp    type plko-txtsp,
        istru    type plko-istru,
        arbid    type plko-arbid,
        plnkn    type plas-plnkn,
        keyfield type string,
        arbpl    type arbpl,
        aufnr    type aufk-aufnr,
      end of ty_plko .
    types:
      begin of ty_plpo,
        plnty type plpo-plnty,
        plnnr type plpo-plnnr,
        zaehl type plpo-zaehl,
        arbid type plpo-arbid,
        ltxa1 type plpo-ltxa1,
        dauno type plpo-dauno,
        arbei type plpo-arbei,
        anzzl type plpo-anzzl,
        plnal type plas-plnal,
        arbpl type crhd-arbpl,
      end of ty_plpo .
    types:
      begin of ty_order_sync,
        work_order     type aufnr,
        notification   type qmnum,
        display_number type string,
        status_icon    type string,
        status_state   type string,
        has_messages   type string,
        type_record    type string,
      end of ty_order_sync .
    types:
      begin of ty_ekgrp,
        ekgrp type t024-ekgrp,
        eknam type t024-eknam,
      end of ty_ekgrp .
    types:
      begin of ty_ekorg,
        ekorg type t024e-ekorg,
        ekotx type t024e-ekotx,
      end of ty_ekorg .
    types:
      begin of ty_matkl,
        matkl type t023t-matkl,
        wgbez type t023t-wgbez,
      end of ty_matkl .
    types:
      begin of ty_lifnr,
        lifnr type lfa1-lifnr,
        name1 type lfa1-lifnr,
        ekorg type lfm1-ekorg,
      end of ty_lifnr .
    types:
      begin of ty_mapl,
        matnr type mara-matnr,
        werks type t001w-werks,
        maktx type makt-maktx,
      end of ty_mapl .
    types:
      begin of ty_act,
        qmnum          type qmma-qmnum,
        manum          type qmma-manum,
        fenum          type qmma-fenum,
        mngrp          type qmma-mngrp, "Code Grp for Activites
        mncod          type qmma-mncod, "Code for Activites
        matxt          type qmma-matxt,
        atv_text       type qpct-kurztext,
        act_text       type string,
        edit_visibilty type boolean,
        del_visibility type boolean,
        status         type string,
        notification   type qmnum,
        keyfield       type string,
        aufnr          type aufnr,
        vornr          type vornr,
        uuid           type string,
        gendate        type string,
      end of ty_act .
    types:
      begin of  ty_equi ,
        qmnum      type viqmel-qmnum,
        equnr      type viqmel-equnr,
        qmtxt      type viqmel-qmtxt,
        aufnr      type viqmel-aufnr,
        qmdab      type viqmel-qmdab,
        seqnr(2)   type c,
        work_order type aufnr,
        keyfield   type string,
      end of ty_equi .
    types:
      begin of ty_tech,
        qmnum          type qmfe-qmnum,
        fenum          type qmfe-fenum,
        otgrp          type qmfe-otgrp,
        oteil          type qmfe-oteil,
        obj_text       type qpct-kurztext,
        fegrp          type qmfe-fegrp,
        fecod          type qmfe-fecod,
        dam_text       type qpct-kurztext,
        fetxt          type qmfe-fetxt,
        bautl          type qmfe-bautl,
        maktx          type makt-maktx,
        urgrp          type qmur-urgrp,
        urcod          type qmur-urcod,
        cus_text       type qpct-kurztext,
        urtxt          type qmur-urtxt,
        qurnum         type qmur-qurnum,
        manum          type qmma-manum,
        act_fenum      type qmma-fenum,
        mngrp          type qmma-mngrp,
        mncod          type qmma-mncod,
        atv_text       type qpct-kurztext,
        matxt          type qmma-matxt,
        itm_text       type string,
        cau_text       type string,
        act_text       type string,
        edit_visibilty type boolean,
        del_visibility type boolean,
        status         type string,
        notification   type qmnum,
        keyfield       type string,
        aufnr          type aufnr,
        vornr          type vornr,
        uuid           type string,
        gendate        type string,
      end of ty_tech .
    types:
      begin of ty_all_afvc,
        aufnr type aufk-aufnr,
        aplzl type afvc-aplzl,
        vornr type afvc-vornr,
        key   type char40,
      end of ty_all_afvc .
    types:
      t_tech type table of ty_tech .
    types:
      t_act type table of ty_act .
    types:
      t_equi type table of ty_equi .
    types:
      t_actt type table of ty_attachment .
    types:
      t_struct type table of ty_struct .
    types:
      t_order type table of ty_order .
    types:
      t_oper type table of ty_order .
    types:
      t_notif type table of ty_order .
    types:
      t_resb type table of ty_resb .
    types:
      t_afvc type table of ty_afvc .
    types:
      t_afab type table of ty_afab .
    types:
      t_tj30t type table of ty_tj30t .
    types:
      t_all_afvc type table of ty_all_afvc .
    types:
      begin of ty_rel_oper,
        vornr type afvc-vornr,
        text  type string,
      end of ty_rel_oper .
    types:
      begin of ty_jobpkg.
            include type ypmnptjobpkg.
    types: keyfield type string.
    types: end of ty_jobpkg .
    types:
      begin of ty_taskliststore.
            include type bapi_alm_order_tasklists_i.
    types: aufnr type aufk-aufnr.
    types: end of ty_taskliststore .
    types:
      begin of ty_clist_field,
        work_order   type string,
        category     type string,
        field_id     type string,
        field_type   type string,
        create_op    type string,
        create_txt   type string,
        short_text   type string,
        description  type string,
        selected     type string,
        std_text_key type string,
        work_center  type string,
      end of ty_clist_field .
    types:
      begin of ty_task,
        aufnr type aufk-aufnr,
        arbpl type crhd-arbpl,
        plnty type plko-plnty,
      end of ty_task .
    types:
      begin of ty_ext_profile,
        kstar type tpext-kstar,
        ekorg type tpext-ekorg,
        ekgrp type tpext-ekgrp,
        matkl type tpext-matkl,
        auart type aufk-auart,
      end of ty_ext_profile .
    types:
      begin of ty_key,
        steus type t430-steus,
        txt   type t430t-txt,
      end of ty_key .

    types:
      begin of ty_trex_search,
        short_text type string,
        full_text  type string,
        material   type string,
      end of ty_trex_search .
    types:
      begin of ty_t435t,
        vlsch type t435t-vlsch,
        txt   type t435t-txt,
      end of ty_t435t.
    data:
      gt_sel_attach type standard table of ypmnptjobpkg .
    data:
      gt_attach_jobpkg type standard table of ty_jobpkg .
    data wa_sel_attach type ypmnptjobpkg .
    data:
      gt_rel_oper type standard table of ty_rel_oper .
    data gt_oci_catalogs type ypm_npt_oci_catalog_t .
    data wa_oci_catalog type ypm_npt_oci_catalog .
    data gv_search_tasks type ty_search_tasks .
    data wa_equi type ty_equi .
    data wa_tech_hist type ty_tech .
    data wa_act_hist type ty_act .
    data wa_resb_hist type ty_resb .
    data:
      gt_attach_hist type table of ty_attachment .
    data:
      gt_equi type table of ty_equi .
    data:
      gt_equi_hist type table of ty_equi .
    data:
      gt_tech_hist type table of ty_tech .
    data:
      gt_act_hist type table of ty_act .
    data:
      gt_resb_hist type table of ty_resb .
    data:
      gt_fl_struct type table of ty_struct .
    data gt_material_text type ypm_material_search_result_t .
    data gt_previous_issue type ypm_material_search_result_t .
    data gt_order_pl type t_order .
    data gt_notif_pl type t_notif .
    data:
      gt_message type standard table of ty_messages .
    data wa_message type ty_messages .
    data:
      gt_order_sync type table of ty_order_sync .
    data:
      lt_arbpl    type table of ty_arbpl .
    data:
      gt_tasklist type table of ty_taskliststore .
    data wa_tasklist type ty_taskliststore .
    data lw_arbpl type ty_arbpl .
    data:
      ra_arbpl    type range of qmel-arbpl .
    data:
      ra_date     type range of sydatum .
    data:
      ra_ingpr type range of afih-ingpr .
    data:
      rw_ingpr like line of ra_ingpr .
    data:
      rw_arbpl    like line of ra_arbpl .
    data:
      rw_date     like line of ra_date .
    data:
      gt_ekgrp type table of ty_ekgrp .
    data:
      gt_ekorg type table of ty_ekorg .
    data:
      gt_matkl type table of ty_matkl .
    data wa_matkl type ty_matkl .
    data:
      gt_lifnr type table of ty_lifnr .
    data:
      gt_t357m_t type table of t357m_t .
    data:
      gt_t024a type table of t024a .
    data:
      gt_mapl type table of ty_mapl .
    data lv_datelow type char20 .
    data lv_datehigh type char20 .
    data:
      gt_createtl type table of ty_task .
    data wa_createtl type ty_task .
    data:
      gt_lines type table of tline .
    data:
      gt_priority   type standard table of ty_priority .
    data:
      gt_noti_types type standard table of ty_noti_types .
    data:
      gt_location   type standard table of ty_location .
    data:
      gt_equipment  type standard table of ty_equipment .
    data:
      gt_act_type   type standard table of ty_act_type .
    data:
      gt_attachments type table of ty_attachment .
    data:
      gt_attachments_pl type table of ty_attachment .
    data:
      gt_attachment_data type table of ty_attachment_data .
    data:
      gt_attachment_data_pl type table of ty_attachment_data .
    data wa_attachment_data type ty_attachment_data .
    data:
      gt_tapl type standard table of ty_tapl .
    data wa_tepl type ty_tapl .
    data:
      gt_tapl_item type standard table of ty_tapl .
    data:
      gt_afab type standard table of ty_afab .
    data wa_afab type ty_afab .
    data:
      gt_eapl type standard table of ty_tapl .
    data:
      gt_eapl_item type standard table of ty_tapl .
    data wa_eapl_item type ty_tapl .
    data:
      gt_plko type standard table of ty_plko .
    data wa_plko type ty_plko .
    data:
      gt_plpo type standard table of ty_plpo .
    data wa_plpo type ty_plpo .
    data wa_priority type ty_priority .
    data wa_location type ty_location .
    data wa_equipment type ty_equipment .
    data:
      gt_afvv type standard table of ty_afvv .
    data wa_afvv type ty_afvv .
    data:
      gt_afvu type standard table of ty_afvu .
    data wa_afvu type ty_afvu .
    data:
      gt_pmco type standard table of ty_pmco .
    data wa_pmco type ty_pmco .
    data:
*    data:
*      gt_maint_cl type standard table of ty_maint_checklist .
      gt_maint_cl type standard table of ty_maint_checklist .
    data gv_maint_cl type ty_maint_checklist .
    data:
      gt_notiflist type table of ty_notilist .
    data:
      gt_notiflist_outbox type table of ty_noti_detail .
    data:
      gt_worklist type table of ty_worklist .
    data:
      gt_operlist type table of ty_worklist .
    data gt_oper_pl type t_oper .
    data wa_operlist type ty_worklist .
    data wa_notilist type ty_notilist .
    data wa_worklist type ty_worklist .
    data:
      gt_workcenter type table of ty_work .
    data:
      gt_workcenter_oper type table of ty_work .
    data:
      gt_tj30t type standard table of tj30t .
    data:
      gt_status type standard table of ty_tj30 .
    data:
      gt_tj30t_notif type standard table of ty_tj30t .
    data:
      gt_exp     type standard table of ty_ext_profile .
    data:
      gt_exp_mat type standard table of ty_ext_profile .
    data:
      begin of wa_default ,
        wrk_center type string,
        arbpl      type string,
        oper_arbpl type string,
        oper_wrk   type string,
        gt_range   type string,
        status     type string,
        estat      type string,
        ingpr      type string,
        ingpr_text type string,
        beber      type t357-beber,
        phase0     type boolean,
        phase1     type boolean,
        noti_sel   type boolean,
        ordr_sel   type boolean,
        oper_sel   type boolean,
      end of wa_default .
    data:
      gt_revision type standard table of t352r .
    data wa_revision type t352r .
    data wa_act_type type ty_act_type .
    data:
      gt_afvc type table of ty_afvc .
    data:
      gt_all_afvc type table of ty_all_afvc .
    data:
      gt_afvc_del type table of ty_afvc .
    data wa_afvc_del type ty_afvc .
    data:
      gt_afvc_pl type table of ty_afvc .
    data wa_afvc type ty_afvc .
    data:
      gt_resb type table of ty_resb .
    data:
      gt_resb_pl type table of ty_resb .
    data:
      gt_resb1 type table of ty_resb .
    data wa_resb type ty_resb .
    data wa_head type thead .
    data wa_lines type tline .
    data gv_noti_detail type ty_noti_detail .
    data:
      gt_noti_detail type table of ty_noti_detail .
    data:
      gt_noti_detail_pl type table of ty_noti_detail .
    data gv_ord_detail type ty_ord_detail .
    data gv_noti_conv type ty_noti_detail .
    data:
      gt_ord_detail    type standard table of ty_ord_detail .
    data:
      gt_ord_detail_pl type standard table of ty_ord_detail .
    data:
      gt_plantsection type table of t357 .
    data:
      gt_key type table of ty_key .
    data wa_key type ty_key .
    data:
      gt_uom type table of t006 .
    data:
      gt_curr type table of tcurc .
    data :
      gt_t435 type table of ty_t435t.
    data:
      gt_external type table of ypmservices .
    data:
      gt_checklist type table of ty_clist_field .
    data gv_message_id type symsgid value 'YPM_NEPTUNE' ##NO_TEXT.
    data count type i .
    data tot_count type i .
    data wa_trex_search type ty_trex_search .

    data: begin of wa_photo_info,
            data type string,
          end of wa_photo_info.

    methods get_workcenters
      importing
        !ajax_value type string .
    methods get_notifications .
    methods get_orders .
    methods get_data .
    methods get_operations
      importing
        !ajax_value  type string
      exporting
        !et_resb     type t_resb
        !et_afvc     type t_afvc
        !et_afab     type t_afab
        !et_all_afvc type t_all_afvc .
    methods read_text
      importing
        !wa_head                type thead
        !iv_preserve_formatting type flag default abap_true
      exporting
        !text                   type string .
    methods get_attachments_list
      importing
        !ajax_value type string .
    methods get_attachments_data .
    methods save_order .
    methods get_notification_details
      importing
        !ajax_value     type string
      exporting
        !gv_noti_detail type ty_noti_detail
        !et_tj30t_notif type t_tj30t .
    methods get_data_f4 .
    methods convert_noti_to_order .
    methods generate_relation .
    methods generate_relationships .
    methods get_general_tasklist .
    methods get_assembly
      importing
        !ajax_value type string .
    methods operation_save .
    methods get_order_details
      importing
        !ajax_value type string .
    methods create_tasklist
      importing
        !aufnr type aufk-aufnr optional .
    methods get_equipment_history
      importing
        !iv_work_order type aufnr
      exporting
        !et_tech_hist  type t_tech
        !et_act_hist   type t_act
        !et_resb_hist  type t_resb
        !et_equi       type t_equi
        !et_attach     type t_actt .
protected section.

  methods GET_CHECK_LIST .
  methods PREPARE_LONG_TEXT
    importing
      !IV_LONG_TEXT type STRING
    returning
      value(RT_TEXT_LINES) type RSFBTLTAB .
  methods VALIDATE_MATERIAL
    importing
      !IV_MATERIAL type MATNR
      !IV_PLANT type WERKS_D
    raising
      YCX_NPT_EXCEPTIONS .
  methods SEARCH_MATERIAL_TEXT .
private section.

  methods GET_WORKCENTER_ID .
  methods GET_CATALOGS .
  methods GET_CATALOG_ORDER
    importing
      !IR_SERVER type ref to /NEPTUNE/CL_NAD_SERVER .
  methods GET_WORKCENTER_OPER
    importing
      !AJAX_VALUE type STRING .
ENDCLASS.



CLASS YCL_PM_PLANNER_CLASS IMPLEMENTATION.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->/NEPTUNE/IF_NAD_SERVER~HANDLE_ON_AJAX
* +-------------------------------------------------------------------------------------------------+
* | [--->] APPLID                         TYPE        STRING
* | [--->] AJAX_ID                        TYPE        STRING
* | [--->] AJAX_VALUE                     TYPE        STRING
* | [--->] SERVER                         TYPE REF TO /NEPTUNE/CL_NAD_SERVER
* | [--->] REQUEST                        TYPE        /NEPTUNE/DATA_REQUEST
* | [<-->] NAVIGATION                     TYPE        /NEPTUNE/AJAX_NAVIGATION
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method /neptune/if_nad_server~handle_on_ajax.

    case ajax_id.
      when 'GET_WC'.
        get_workcenters( ajax_value ).
      when 'GET_WC_OPER'.
        get_workcenter_oper( ajax_value ).
      when 'GET_DATA'.
        get_data( ).
      when 'GET_NOTIFICATION_DETAILS'.
        call method me->get_notification_details
          exporting
            ajax_value     = ajax_value
          importing
            gv_noti_detail = gv_noti_detail
            et_tj30t_notif = gt_tj30t_notif.
      when 'GET_ORDER_DETAILS'.
        call method get_order_details( ajax_value ).
        call METHOD get_assembly( ajax_value ).
      when 'SAVE_ORDER'.
        call method save_order( ).
      when 'CONVERT_NOTI_TO_ORDER'.
        call method convert_noti_to_order( ).

      when 'SEARCH_MATERIAL_TEXT'.
        search_material_text( ).
      when 'GET_OCI_CATALOGS'.
        get_catalogs( ).
      when 'GENERATE_RELATION'.
        generate_relationships( ).
      when 'GET_CATALOG_ORDER'.
        get_catalog_order( server ).
      when 'GET_WORKCENTER_ID'.
        call method get_workcenter_id( ).
      when 'GET_GENERAL_TASKLIST'.
        call method get_general_tasklist( ).
      when 'GET_CHECK_LIST'.
        get_check_list( ).
      when 'OPERATION_SAVE'.
        operation_save( ).
*      call method me->get_operation_detail
*        exporting
*          ajax_value = ajax_value
*        importing
*          et_resb    = gt_resb
*          et_afvc    = gt_afvc
*          et_afab    = gt_afab
          .


    endcase.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->/NEPTUNE/IF_NAD_SERVER~HANDLE_ON_REQUEST
* +-------------------------------------------------------------------------------------------------+
* | [--->] APPLID                         TYPE        STRING
* | [--->] SERVER                         TYPE REF TO /NEPTUNE/CL_NAD_SERVER
* | [--->] KEY_ID                         TYPE        STRING(optional)
* | [--->] KEY                            TYPE        STRING
* | [--->] REQUEST                        TYPE        /NEPTUNE/DATA_REQUEST
* | [<-->] NAV_TO                         TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method /neptune/if_nad_server~handle_on_request.
    data: lv_expiry_time type tims,
          lr_mime_api    type ref to if_mr_api,
          lv_data        type xstring.

    case key.
      when 'OCI_RETURN'.
*     Export results of external catalog call to the database.
        lv_expiry_time = sy-uzeit + 60.
        cl_bsp_server_side_cookie=>set_server_cookie(
          name                  = 'OCIRETURN'
          application_namespace = '/NEPTUNE'
          application_name      = 'SERVER'
          username              = sy-uname
          session_id            = space
          expiry_date_abs       = sy-datum
          expiry_time_abs       = lv_expiry_time
          data_name             = 'USER'
          data_value            = request-json
        ).

*     Output a static page in the response.
        lr_mime_api = cl_mime_repository_api=>get_api( ).
        lr_mime_api->get(
          exporting
            i_url     = '/neptune/public/application/ypm_craftperson_appl/catalogorder.html'
          importing
            e_content = lv_data
        ).
        server->api_response_xstring(
          data = lv_data
          content_type = 'text/html'
        ).
        return.
    endcase.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->/NEPTUNE/IF_NAD_SERVER~HANDLE_ON_SUBMIT
* +-------------------------------------------------------------------------------------------------+
* | [--->] APPLID                         TYPE        STRING
* | [--->] EVENT_ID                       TYPE        STRING
* | [--->] EVENT_VALUE                    TYPE        STRING(optional)
* | [--->] SERVER                         TYPE REF TO /NEPTUNE/CL_NAD_SERVER
* | [--->] REQUEST                        TYPE        /NEPTUNE/DATA_REQUEST
* | [<-->] NAV_TO                         TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method /neptune/if_nad_server~handle_on_submit.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->/NEPTUNE/IF_NAD_SERVER~HANDLE_ON_SYNC_IN
* +-------------------------------------------------------------------------------------------------+
* | [--->] APPLID                         TYPE        STRING
* | [--->] LASTSYNCDATE                   TYPE        STRING
* | [--->] IT_SYNC_DATA                   TYPE        /NEPTUNE/SYNC_DATA_TT
* | [<---] EX_STATUS                      TYPE        /NEPTUNE/SYNC_HEADER
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method /neptune/if_nad_server~handle_on_sync_in.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->/NEPTUNE/IF_NAD_SERVER~HANDLE_ON_SYNC_OUT
* +-------------------------------------------------------------------------------------------------+
* | [--->] APPLID                         TYPE        STRING
* | [--->] LASTSYNCDATE                   TYPE        STRING
* | [--->] SERVER                         TYPE REF TO /NEPTUNE/CL_NAD_SERVER
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method /neptune/if_nad_server~handle_on_sync_out.
    types : begin of ty_aufnr,
              aufnr type aufk-aufnr,
            end of ty_aufnr.
    types: begin of ty_oper,
             oper type char100,
           end of ty_oper.
    data :lt_form_fields    type tihttpnvp,
          ls_form_field     type ihttpnvp,
          lv_appsync_info   type string,
          lt_appsync_split  type string_table,
          lv_appsync_split  type string,
          lt_info_fields    type hashed table of ihttpnvp
                                with unique key name,
          ls_info_field     type ihttpnvp,
          lt_work_orders    type table of ty_aufnr,
          lw_order          type ty_aufnr,
          lt_oper           type table of ty_oper,
          lw_oper           type ty_oper,
          lv_aufnr          type aufnr,
          lv_vornr          type vornr,
          lt_history_orders type table of aufnr,
          lt_notif_orders   type table of qmnum,
          lv_notif          type string,
          lt_tj30t          type table of ty_tj30t,
          lt_plko           type table of ty_plko,
          lv_werks          type t001w-werks,
          lv_order          type ty_aufnr,
          lw_afab           type afab,
          lt_operations     type string_table,
          ls_notif          type ty_order,
          ls_order          type ty_order,
          lt_results        type match_result_tab,
          ls_result         type match_result,
          lt_resb           type t_resb,
          lt_afvc           type t_afvc,
          lt_all_afvc       type t_all_afvc,
          lt_afab           type t_afab,
          craft_class       type ref to ycl_pm_craftperson_class,
          lt_fl_struct      type t_struct,
          lt_previous_issue type ypm_material_search_result_t,
          lv_previous       type ypm_material_search_result,
          lv_matnr          type mara-matnr,
          ajax_value        type string,lt_tpir2    type table of tpir2t,
          lw_tpir2          type tpir2t,
          lt_aufk           type table of rihaufk,
          lt_pmco           type table of pmco_ext,
          lt_comp           type table of pmco_kgr,
          lw_comp           type pmco_kgr,
          lw_line           type bsvx-sttxt,
          lw_uline          type bsvx-sttxt,
          lt_tech_hist      type t_tech,
          lt_act_hist       type t_act,
          lt_resb_hist      type t_resb,
          lt_equi           type t_equi,
          lw_aufk           type rihaufk.

* Get information from request.
    server->api_get_form_fields( changing it_form_fields = lt_form_fields ).
    check not lt_form_fields[] is initial.
*     AppSyncInfo is in the first form field of the request.
    read table lt_form_fields into ls_form_field index 1.
    find first occurrence of regex '"info":\{([^\}]+)\}' in ls_form_field-name
        submatches lv_appsync_info.

    check not lv_appsync_info is initial.

* Matches name value pairs in which the value may be either a string or an array.
    find all occurrences of regex '[^:,]*:((?:\[[^\]]*\])|(?:[^,]*))' in lv_appsync_info
        results lt_results.
    loop at lt_results into ls_result.
      clear ls_info_field.
      lv_appsync_split = lv_appsync_info+ls_result-offset(ls_result-length).
      replace all occurrences of '"' in lv_appsync_split with ''.
      replace all occurrences of '[' in lv_appsync_split with ''.
      replace all occurrences of ']' in lv_appsync_split with ''.
      split lv_appsync_split at ':' into ls_info_field-name ls_info_field-value.
      insert ls_info_field into table lt_info_fields.
    endloop.
*    Read Notification details for syncing offline
    read table lt_info_fields into ls_info_field
      with key name = 'notification'.
    if sy-subrc eq 0.
      split ls_info_field-value at ',' into table lt_notif_orders.
      sort lt_notif_orders.
      delete adjacent duplicates from lt_notif_orders.
    endif.

    if lt_notif_orders[] is not initial.
      loop at lt_notif_orders into lv_notif.
*   Get Notification details
        call method me->get_notification_details
          exporting
            ajax_value     = lv_notif
          importing
            gv_noti_detail = gv_noti_detail
            et_tj30t_notif = lt_tj30t.

        append gv_noti_detail to gt_noti_detail.
        append lines of lt_tj30t to gt_tj30t_notif.
        ls_notif-keyfield = lv_notif.
        append ls_notif to gt_notif_pl.
      endloop.
      sort gt_noti_detail by qmnum.
      gt_noti_detail_pl[] = gt_noti_detail.
    endif.
*    Read Orders for syncing data
    read table lt_info_fields into ls_info_field
         with key name = 'workOrders'.
    if sy-subrc eq 0.
      split ls_info_field-value at ',' into table lt_work_orders.
      sort lt_work_orders.
      delete adjacent duplicates from lt_work_orders.
    endif.
*   Read Operations
    read table lt_info_fields into ls_info_field
              with key name = 'Operations'.
    if sy-subrc eq 0.
      split ls_info_field-value at ',' into table lt_oper.
      loop at lt_oper into lw_oper.
        split lw_oper-oper at '-' into lv_aufnr lv_vornr.
        lw_order-aufnr = lv_aufnr.
        append lw_order to lt_work_orders.
      endloop.
    endif.
    if lt_work_orders[] is not initial.
      clear : lv_notif.
      loop at lt_work_orders into lv_order.
        ls_order-keyfield = lv_order-aufnr.
        append ls_order to gt_order_pl.
      endloop.

      loop at lt_oper into lw_oper.
        ls_order-keyfield = lw_oper-oper.
        append ls_order to gt_oper_pl.
      endloop.
      select     a~aufnr
                 a~gltrp
                 a~gstrp
                 a~gsuzp
                 a~gluzp
                 b~erdat
                 b~werks
                 b~user4
                 b~objnr
                 b~vaplz
                 b~waers
                 b~phas0
                 b~phas1
                 b~ktext
                 c~priok
                 c~iloan
                 c~equnr
                 c~ilart
                 c~revnr
                 c~ingpr
                 from afko as a inner join aufk as b
                 on a~aufnr eq b~aufnr inner join afih as c
                 on b~aufnr eq c~aufnr
                 into corresponding fields of table gt_ord_detail for all entries in lt_work_orders
                 where a~aufnr eq lt_work_orders-aufnr.
      if sy-subrc eq 0.

        select * from tpir2t into table lt_tpir2 where langu = sy-langu
                                                    and appl = 'PM'
                                                    and kokrs = '1000'.
        clear : gv_ord_detail.
        sort gt_ord_detail by aufnr.
        create object craft_class. "object class for getting details from craftperson
        loop at gt_ord_detail into gv_ord_detail.
*          planner group description
          select single innam from t024i
                   into gv_ord_detail-ingpr_text
                    where iwerk = gv_ord_detail-werks
                     and  ingrp = gv_ord_detail-ingpr.
          clear : count,
                  tot_count.
*          2/13/18 -- > Adding status to downloaded data
          gv_ord_detail-icon = 'sap-icon://activity-2'.
          gv_ord_detail-color = 'Success'.
          if gv_ord_detail-phas0 = 'X'.
            gv_ord_detail-status = 'Created'.
          else.
            gv_ord_detail-status = 'Released'.
          endif.

*    Get the default control key from main work center
          select single steus from crhd into gv_ord_detail-steus
                              where objty = 'A'
                               and arbpl = gv_ord_detail-vaplz
                               and werks = gv_ord_detail-werks.
*      get the header user status
          call function 'STATUS_TEXT_EDIT'
            exporting
              flg_user_stat    = 'X'
              objnr            = gv_ord_detail-objnr
              spras            = sy-langu
            importing
              line             = lw_line
              user_line        = lw_uline
            exceptions
              object_not_found = 1
              others           = 2.
          if sy-subrc <> 0.
* Implement suitable error handling here
          endif.
          if lw_uline is not initial.
            if lw_uline cs 'CKLT'.
              gv_ord_detail-cklt = 'true'.
              count = count + 1.
            endif.
            if lw_uline cs 'OPRC'.
              gv_ord_detail-oprc = 'true'.
              count = count + 1.
            endif.
            if lw_uline cs 'DETC'.
              gv_ord_detail-detc = 'true'.
              count = count + 1.
            endif.
          endif.

*        Get function location details
          select single tplnr
                  from iloa
                  into gv_ord_detail-tplnr
                  where iloan eq gv_ord_detail-iloan.
          select single pltxt
                from iflotx
                into gv_ord_detail-loc_detail
                where tplnr = gv_ord_detail-tplnr
                 and spras = sy-langu.
*          Activity type detail
          select single ilatx
              from t353i_t
              into gv_ord_detail-act_detail
               where ilart = gv_ord_detail-ilart
                and spras eq sy-langu.
*       Revision text
          select single revtx
                from t352r
             into gv_ord_detail-rev_text
             where  revnr eq gv_ord_detail-revnr
            and iwerk eq gv_ord_detail-werks
              and  revab eq space.

*   Long text
          wa_head-tdname = gv_ord_detail-aufnr.
          wa_head-tdid = 'KOPF'.
          wa_head-tdobject = 'AUFK'.
          wa_head-tdspras = sy-langu.

          call method me->read_text
            exporting
              wa_head                = wa_head
              iv_preserve_formatting = abap_true
            importing
              text                   = gv_ord_detail-long_text.
*   Get operations
          ajax_value = gv_ord_detail-aufnr.
          refresh : lt_resb,
                    lt_afvc,
                    lt_afab.
          get_operations(
          exporting
             ajax_value = ajax_value
         importing
           et_resb = lt_resb
           et_afvc = lt_afvc
           et_afab = lt_afab
           et_all_afvc = lt_all_afvc ).

          append lines of lt_resb to gt_resb.
          append lines of lt_afvc to gt_afvc.
          append lines of lt_afab to gt_afab.
          append lines of lt_all_afvc to gt_all_afvc.
*   Claculate progress tracking
          tot_count = tot_count + 3.
          if count > 0.
            gv_ord_detail-prcnt = ( count / tot_count ) * 100.
          else.
            gv_ord_detail-progress = '0'.
          endif.
          gv_ord_detail-progress = gv_ord_detail-prcnt.
          concatenate gv_ord_detail-progress '%' into gv_ord_detail-progress.

*      Get Material BOM search Tree
          call method craft_class->get_fl_struct
            exporting
              iv_work_order = gv_ord_detail-aufnr
            importing
              et_fl_struct  = lt_fl_struct.
          append lines of lt_fl_struct to gt_fl_struct.
*Material parts history search

          call method craft_class->get_previous_issue
            exporting
              iv_work_order     = gv_ord_detail-aufnr
            receiving
              rt_previous_issue = lt_previous_issue.
          loop at lt_previous_issue into lv_previous.
            clear : lv_matnr.
            call function 'CONVERSION_EXIT_MATN1_INPUT'
              exporting
                input        = lv_previous-material
              importing
                output       = lv_matnr
              exceptions
                length_error = 1
                others       = 2.
            if sy-subrc <> 0.
* Implement suitable error handling here
            endif.

            select single bklas from mbew into lv_previous-bklas
                                              where matnr = lv_matnr.
            if sy-subrc eq 0.
*          exclude valutation class which has non stock materials
              if lv_previous-bklas = '0018'.
                delete lt_previous_issue where material = lv_previous-material.
              endif.
            endif.
          endloop.
          append lines of lt_previous_issue to gt_previous_issue.
*        Get attachment list
          ajax_value = gv_ord_detail-aufnr.
          get_attachments_list( ajax_value ).
*        Get functionlocation task list
          select  a~plnty
               a~plnnr
               a~plnal
               a~zaehl
               a~datuv
               a~ktext appending corresponding fields of table gt_tapl
              from plko as a inner join tapl as b
              on a~plnty = b~plnty and a~plnnr = b~plnnr
                        where a~datuv le gv_ord_detail-gstrp
                         and  b~plnty = 'T'
                         and  b~iwerk = gv_ord_detail-werks
                          and b~tplnr = gv_ord_detail-tplnr.
          loop at gt_tapl into wa_tepl.
            if wa_tepl-aufnr is initial.
              wa_tepl-aufnr = gv_ord_detail-aufnr.
              modify gt_tapl from wa_tepl.
            endif.
          endloop.
*        Get Equipment task list
          select  a~plnty
                 a~plnnr
                 a~plnal
                 a~zaehl
                 a~datuv
                 a~ktext appending corresponding fields of table gt_eapl
              from plko as a inner join eapl as b
              on a~plnty = b~plnty and a~plnnr = b~plnnr
                        where a~datuv le gv_ord_detail-gstrp
                         and b~plnty = 'E'
                         and  b~iwerk = gv_ord_detail-werks
                          and b~equnr = gv_ord_detail-equnr.
          loop at gt_eapl into wa_tepl.
            if wa_tepl-aufnr is initial.
              wa_tepl-aufnr = gv_ord_detail-aufnr.
              modify gt_eapl from wa_tepl.
            endif.
          endloop.

*            Equipment Text
          select single eqktx from eqkt into gv_ord_detail-equi_text
          where equnr eq gv_ord_detail-equnr
          and spras eq sy-langu.

          call function 'CONVERSION_EXIT_ALPHA_OUTPUT'
            exporting
              input  = gv_ord_detail-equnr
            importing
              output = gv_ord_detail-equnr.



          call function 'CONVERSION_EXIT_TPLNR_OUTPUT'
            exporting
              input  = gv_ord_detail-tplnr
            importing
              output = gv_ord_detail-tplnr.
*      Get General task Lists
          select single objid from crhd into wa_plko-arbid
                              where arbpl = gv_ord_detail-vaplz
                                and werks = gv_ord_detail-werks.
          refresh : lt_plko.
          select plnty plnnr plnal zaehl datuv verwe werks
                statu ktext txtsp arbid  from plko
                  into table lt_plko where plnty = 'A'
                                      and statu in ( '2', '4', '5' )
                                      and arbid = wa_plko-arbid
                                      and datuv le gv_ord_detail-gstrp
                                      and werks = gv_ord_detail-werks.
          loop at lt_plko into wa_plko.
            wa_plko-keyfield = wa_plko-plnty && wa_plko-plnnr &&
                                 wa_plko-plnal && wa_plko-zaehl.
            wa_plko-arbpl = gv_ord_detail-vaplz.
            wa_plko-aufnr = gv_ord_detail-aufnr.
            modify lt_plko from wa_plko.
          endloop.
          append lines of lt_plko to gt_plko.
*     Get Estimated Costs
          clear : lw_aufk.
          refresh : lt_aufk,
                    lt_comp,
                    lt_pmco.

          move-corresponding gv_ord_detail to lw_aufk.
          append lw_aufk to lt_aufk.

          call function 'PM_WORKORDER_COSTS_LIST'
            exporting
              list_currency  = gv_ord_detail-waers
              pmco_detail    = 'X'
              all_currencies = 'X'
              external_call  = 'X'
            tables
              list_aufk      = lt_aufk
              list_pmco      = lt_pmco
              comp_pmco      = lt_comp
            exceptions
              no_orders      = 1
              no_currency    = 2
              no_costs_found = 3
              others         = 4.
          if sy-subrc <> 0.
* Implement suitable error handling here
          endif.

          loop at lt_tpir2 into lw_tpir2.
            clear : wa_pmco,
                    lw_comp.
            read table lt_comp into lw_comp with key acpos = lw_tpir2-acpos.
            if sy-subrc eq 0.
              move-corresponding lw_comp to wa_pmco.
            else.
              wa_pmco-acpos = lw_tpir2-acpos.
              wa_pmco-aufnr = gv_ord_detail-aufnr.
            endif.
            wa_pmco-waers = 'USD'.
            wa_pmco-ktext = lw_tpir2-ktext.
            wa_pmco-keyfield = wa_pmco-aufnr && wa_pmco-acpos.
            append wa_pmco to gt_pmco.
          endloop.
*          modify updated data to table
          modify gt_ord_detail from gv_ord_detail.
*     Equipment history
          get_equipment_history(
            exporting
              iv_work_order = gv_ord_detail-aufnr
            importing
              et_equi       = lt_equi
              et_tech_hist  = lt_tech_hist
              et_act_hist   = lt_act_hist
              et_resb_hist  = lt_resb_hist
          ).
          append lines of:
              lt_equi to gt_equi_hist,
              lt_tech_hist to gt_tech_hist,
              lt_act_hist to gt_act_hist,
              lt_resb_hist to gt_resb_hist.
          clear : gv_ord_detail.
        endloop.
        gt_ord_detail_pl[] = gt_ord_detail[].
        gt_resb_pl[] = gt_resb[].
        gt_afvc_pl[] = gt_afvc[].

        sort gt_tapl .
        delete adjacent duplicates from gt_tapl comparing all fields.
        if not gt_tapl[] is initial.
*        get the function location item values
          select a~plnty a~plnnr a~zaehl a~datuv a~arbid a~ltxa1 a~dauno a~arbei a~anzzl
                                b~plnal from plpo as a
                              inner join plas as b on a~plnnr = b~plnnr
                                              and a~plnkn = b~plnkn into
                          corresponding fields of table gt_tapl_item
                            for all entries in gt_tapl
                            where a~plnty = 'T'
                              and a~plnnr = gt_tapl-plnnr
                             and b~plnal = gt_tapl-plnal.
          if sy-subrc eq 0.
            sort gt_tapl_item by plnnr plnal.
            clear : wa_eapl_item.
            loop at gt_tapl_item into wa_eapl_item.
              select single arbpl into wa_eapl_item-arbpl from crhd
                                      where objid = wa_eapl_item-arbid
                                        and objty = 'A'.
              if sy-subrc eq 0.
                modify gt_tapl_item from wa_eapl_item.
              endif.
            endloop.
            sort gt_tapl_item by plnnr plnal zaehl.
          endif.
        endif.
*        get the equipment item values
        if not gt_eapl[] is initial.
          sort gt_eapl by plnnr plnal.
          select a~plnty a~plnnr a~zaehl a~arbid a~datuv a~arbid a~ltxa1 a~dauno a~arbei a~anzzl
                                  b~plnal from plpo as a
                          inner join plas as b on a~plnnr = b~plnnr
                                              and a~plnkn = b~plnkn into
                            corresponding fields of table gt_eapl_item
                                   for all entries in gt_eapl
                                   where a~plnty = 'E'
                                     and a~plnnr = gt_eapl-plnnr
                                     and b~plnal = gt_eapl-plnal.
          if sy-subrc eq 0.
            sort gt_eapl_item by plnnr plnal.
            clear : wa_eapl_item.
            loop at gt_eapl_item into wa_eapl_item.
              select single arbpl into wa_eapl_item-arbpl from crhd
                                      where objid = wa_eapl_item-arbid
                                        and objty = 'A'.
              if sy-subrc eq 0.
                modify gt_eapl_item from wa_eapl_item.
              endif.
            endloop.
            sort gt_eapl_item by plnnr plnal zaehl.
          endif.
        endif.
*        Get general task list items
        sort gt_plko by aufnr plnnr plnal.
        if not gt_plko[] is initial.
          select a~plnty a~plnnr a~zaehl a~arbid a~ltxa1 a~dauno a~arbei a~anzzl
                          b~plnal from plpo as a
                      inner join plas as b on a~plnnr = b~plnnr
                                          and a~plnkn = b~plnkn
                      into table gt_plpo for all entries in gt_plko
                                where a~plnty = 'A'
                                  and a~plnnr = gt_plko-plnnr
                                  and b~plnal = gt_plko-plnal.
          if sy-subrc eq 0.
            sort gt_plpo by plnnr plnal.
            loop at gt_plpo into wa_plpo.
              select single arbpl into wa_plpo-arbpl from crhd
                                      where objid = wa_plpo-arbid
                                        and objty = 'A'.
              if sy-subrc eq 0.
                modify gt_plpo from wa_plpo.
              endif.
            endloop.
            sort gt_plpo by plnnr plnal zaehl.
          endif.
        endif.

        get parameter id 'IWK' field lv_werks.

*      Get attachments
        sort gt_attachments by work_order sort_group file_name.
        get_attachments_data( ).
        gt_attachments_pl[] = gt_attachments[].
        gt_attachment_data_pl[] = gt_attachment_data[].
      endif.
    endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->CONVERT_NOTI_TO_ORDER
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method convert_noti_to_order.
    types: begin of s_stat,
             stat  type j_estat,
             txt04 type j_txt04,
             stonr type tj30-stonr,
           end of s_stat.
    types : begin of ty_ltext,
              text type string_table,
            end of ty_ltext.
    types: begin of ty_user,
             user type bapi2080_notusrstati-status_ext,
           end of ty_user.
    data: t_methods      type standard table of bapi_alm_order_method,
          t_header       type standard table of bapi_alm_order_headers_i,
          t_header_up    type standard table of bapi_alm_order_headers_up,
          t_return       type standard table of bapiret2,
          w_return       type bapiret2,
          w_header       type  bapi_alm_order_headers_i,
          w_header_up    type bapi_alm_order_headers_up,
          t_operation    type table of bapi_alm_order_operation,
          w_operation    type bapi_alm_order_operation,
          t_operation_up type table of bapi_alm_order_operation_up,
          w_operation_up type bapi_alm_order_operation_up,
          w_methods      type bapi_alm_order_method,
          t_numbers      type standard table of bapi_alm_numbers,
          w_numbers      type bapi_alm_numbers,
          lt_notifhead   type bapi2080_nothdri,
          lt_notifheadx  type bapi2080_nothdri_x,
          lt_head_export type bapi2080_nothdre,
          lt_table       type standard table of string,
          lw_table       type string,
          lt_user        type table of ty_user,
          lw_user        type ty_user,
          lt_line        type tline,
          lt_text_cr     type /emn/pm_t_tdline,
          lw_text_cr     type /emn/pm_s_tdline,
          lt_streamline  type ty_ltext,
          lt_text         type standard table of bapi2080_notfulltxti,
          lw_text         type bapi2080_notfulltxti,
          lt_stat        type hashed table of s_stat with unique key txt04,
          lw_stat        type s_stat,
          lv_stsma       type j_stsma.

    data: lv_temp        type char15 value '%00000000001',
          lv_tmp_orderid type objidext,
          lv_vornr       type afvc-vornr,
          lv_aufnr       type qmel-aufnr,
          status         type bapi2080_notusrstati.
    data : lt_info       type table of uinfo2,
           wa_info       type uinfo2,
           lt_return_msg type bapiret2_t.
    data : ln type i.

*   Get user statuses
    select single stsma into lv_stsma
        from jsto
        where objnr = gv_noti_conv-objnr.

    select jest~stat tj30t~txt04 tj30~stonr into table lt_stat
        from jest
        inner join tj30t on jest~stat = tj30t~estat
        inner join tj30 on tj30~stsma = tj30t~stsma
                        and tj30~estat = tj30t~estat
        where jest~objnr  = gv_noti_conv-objnr
          and jest~inact  = space
          and tj30t~stsma = lv_stsma
          and tj30t~spras = 'E'.

*save changes notifications
    lt_notifhead-funct_loc = gv_noti_conv-tplnr.
    lt_notifhead-pm_wkctr = gv_noti_conv-arbpl.
    lt_notifhead-equipment = gv_noti_conv-equnr.
    lt_notifhead-short_text = gv_noti_conv-qmtxt.
    lt_notifhead-priority = gv_noti_conv-priok.
    lt_notifhead-plangroup = gv_noti_conv-ingrp.

    lt_notifheadx-funct_loc = 'X'.
    lt_notifheadx-pm_wkctr = 'X'.
    lt_notifheadx-equipment = 'X'.
    lt_notifheadx-short_text = 'X'.
    lt_notifheadx-priority = 'X'.
    lt_notifheadx-plangroup = 'X'.

*     D.Rempe - 11/7/2017 - conversion is necessary to
*               avoid errors when using functional locations
*               with spaces.
    call function 'CONVERSION_EXIT_TPLNR_INPUT'
      exporting
        input  = lt_notifhead-funct_loc
      importing
        output = lt_notifhead-funct_loc.


    call function 'BAPI_ALM_NOTIF_DATA_MODIFY'
      exporting
        number             = gv_noti_conv-qmnum
        notifheader        = lt_notifhead
        notifheader_x      = lt_notifheadx
      importing
        notifheader_export = lt_head_export
      tables
        return             = t_return.
    if sy-subrc eq 0 and t_return[] is initial.
      call function 'BAPI_ALM_NOTIF_SAVE'
        exporting
          number = gv_noti_conv-qmnum
        tables
          return = t_return.
      if sy-subrc eq 0.
        commit work and wait.
      endif.
      if gv_noti_conv-lg_text_n ne space.
*          Long text
        lw_text_cr-tdline = gv_noti_conv-lg_text_n.
        append lw_text_cr to lt_text_cr.
        loop at lt_text_cr into data(ls_textcreate).
          append ls_textcreate-tdline to lt_streamline-text.
          call function 'CONVERT_STREAM_TO_ITF_TEXT'
            exporting
              stream_lines = lt_streamline-text
              language     = sy-langu
              lf           = 'X'
            tables
              itf_text     = gt_lines.
        endloop.
        wa_head-tdobject = 'QMEL'.
        wa_head-tdid = 'LTXT'.
        wa_head-tdname = gv_noti_conv-qmnum.
        wa_head-tdspras  = sy-langu.
*        changed to lock the Notifications types MC and M2 long text
*          Delete existing text and save the long text.
          call function 'DELETE_TEXT'
            exporting
             CLIENT          = SY-MANDT
              id              = 'LTXT'
              language        = sy-langu
              name            = wa_head-tdname
              object          = 'QMEL'
              savemode_direct = 'X'
*             TEXTMEMORY_ONLY = ' '
*             LOCAL_CAT       = ' '
            exceptions
              not_found       = 1
              others          = 2.
          if sy-subrc <> 0.
* Implement suitable error handling here
          endif.

          loop at gt_lines into wa_lines.
            lw_text-objtype = 'QMEL'.
            lw_text-format_col = '*'.
            lw_text-text_line = wa_lines-tdline.
            append lw_text to lt_text.
          endloop.
          call function 'BAPI_ALM_NOTIF_DATA_ADD'
            exporting
              number     = gv_noti_conv-qmnum
            tables
              notfulltxt = lt_text
              return     = t_return.
          if t_return[] is initial.
            call function 'BAPI_ALM_NOTIF_SAVE'
              exporting
                number = gv_noti_conv-qmnum
              tables
                return = t_return.
            if t_return[] is initial.
              call function 'BAPI_TRANSACTION_COMMIT'
                exporting
                  wait = 'X'.
            endif.
          endif.
      endif.

*  D.Rempe - 2/1/2018 - Dequeue is necessary
*            to avoid lock errors.
      call function 'DEQUEUE_ALL'
        exporting
          _synchron = 'X'.

*  Update user Status
*      if gv_noti_conv-usrstatus ne space.
        split gv_noti_conv-usrstatus at space into table lt_user.
*          split wa_afvc-usrst at space into table lt_user.
        loop at lt_user into lw_user.
*           Don't do anything if the status is already set.
          read table lt_stat
              with key txt04 = lw_user-user
              transporting no fields.
          if sy-subrc = 0.
            continue.
          endif.

          status-status_ext = lw_user-user.
          status-langu = sy-langu.
          call function 'BAPI_ALM_NOTIF_CHANGEUSRSTAT'
            exporting
              number     = gv_noti_conv-qmnum
              usr_status = status
            tables
              return     = t_return.

          read table t_return with key type = 'E'
              transporting no fields.
          if sy-subrc <> 0.
            call function 'BAPI_ALM_NOTIF_SAVE'
              exporting
                number = gv_noti_conv-qmnum
              tables
                return = t_return.
            call function 'BAPI_TRANSACTION_COMMIT'
              exporting
                wait = 'X'.
            delete lt_user where user = lw_user-user.
*            commit work.
          else.
            rollback work.
          endif.
        endloop.
*        deactivate the user status
        loop at lt_stat into lw_stat.
          read table lt_user into lw_user with key user = lw_stat-txt04.
          if sy-subrc ne 0 and lw_stat-stonr ne '01'.
            status-status_ext = lw_stat-txt04.
            status-langu = sy-langu.
            call function 'BAPI_ALM_NOTIF_CHANGEUSRSTAT'
              exporting
                number       = gv_noti_conv-qmnum
                usr_status   = status
                set_inactive = 'X'
              tables
                return       = t_return.

            read table t_return with key type = 'E'
                transporting no fields.
            if sy-subrc <> 0.
              call function 'BAPI_ALM_NOTIF_SAVE'
                exporting
                  number = gv_noti_conv-qmnum
                tables
                  return = t_return.
              call function 'BAPI_TRANSACTION_COMMIT'
                exporting
                  wait = 'X'.
              delete lt_user where user = lw_user-user.
*            commit work.
            else.
              rollback work.
            endif.
          endif.
        endloop.
*      endif.
    endif.

*     Get the Logon Langu
    call function 'TH_LONG_USR_INFO'
      tables
        user_info = lt_info.
    describe table lt_info lines ln.
    read table lt_info into wa_info index ln.

    read table t_return into w_return with key type = 'E'.
    if sy-subrc ne 0.

      select single aufnr from qmel into lv_aufnr
                  where qmnum = gv_noti_conv-qmnum.
      if sy-subrc eq 0 and lv_aufnr is initial.
        concatenate lv_temp gv_noti_conv-qmnum into lv_tmp_orderid.
*  2/12/18  - check if notification is converted in front end.
*  Below logic will excute only user converts the notification to order
        if gv_noti_conv-chng = 'X'.
*       Methods
          w_methods-refnumber = '000001'.
          w_methods-objecttype = 'HEADER'.
          w_methods-method = 'CREATETONOTIF'.
          w_methods-objectkey = lv_tmp_orderid.
          append w_methods to t_methods.
          clear w_methods.

          w_methods-refnumber = '000001'.
          w_methods-objecttype = ''.
          w_methods-method = 'SAVE'.
          w_methods-objectkey = ''.
          append w_methods to t_methods.
          clear w_methods.

*Header
          call function 'CONVERSION_EXIT_TPLNR_INPUT'
            exporting
              input     = gv_noti_conv-tplnr
            importing
              output    = gv_noti_conv-tplnr
            exceptions
              not_found = 1
              others    = 2.
          w_header-notif_no = gv_noti_conv-qmnum .
          w_header-notif_type = ''.
          w_header-order_type = gv_noti_conv-auart.
          w_header-mn_wk_ctr = gv_noti_conv-arbpl2.
          w_header-plant = gv_noti_conv-arbplwerk.
          w_header-pmacttype = gv_noti_conv-ilart.
          w_header-priority = gv_noti_conv-priok.
          w_header-funct_loc = gv_noti_conv-tplnr.
          w_header-equipment = gv_noti_conv-equnr.
          append w_header to t_header.
          clear w_header.

*    Header Up
          w_header_up-notif_no = 'X'.
          w_header_up-notif_type = 'X'.
          append w_header_up to t_header_up.

* Operation
          lv_vornr = '0010'.
          w_methods-refnumber  = '000001'.
          w_methods-method     = 'CREATE'.
          w_methods-objecttype = 'OPERATION'.
          concatenate lv_temp lv_vornr  into w_methods-objectkey.
          append w_methods to  t_methods.

          w_operation-langu = sy-langu.
          w_operation-plant           = gv_noti_conv-arbplwerk.
          w_operation-control_key     = 'PM01'.
          w_operation-activity = lv_vornr.
          w_operation-description = gv_noti_conv-qmtxt.
          w_operation-work_cntr = gv_noti_conv-arbpl2.
          append w_operation to t_operation.

          w_operation_up-langu = 'X'.
          w_operation_up-plant = 'X'.
          w_operation_up-control_key  = 'X'.
          w_operation_up-activity = 'X'.
          w_operation_up-description = 'X'.
          w_operation_up-work_cntr = 'X'.
          append w_operation_up to t_operation_up.
          refresh : t_return.
          call function 'BAPI_ALM_ORDER_MAINTAIN'
            tables
              it_methods      = t_methods
              it_header       = t_header
              it_header_up    = t_header_up
              it_operation    = t_operation
              it_operation_up = t_operation_up
              return          = t_return
              et_numbers      = t_numbers.


          read table t_return into w_return with key type = 'E'.

          if sy-subrc ne 0.
            delete t_return where message_v2 = space.
            call function 'BAPI_TRANSACTION_COMMIT'
              exporting
                wait = 'X'.
          endif.


*    *Create message
          loop at t_return into w_return.
            call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
              exporting
                i_langu                 = wa_info-lang
                i_msgid                 = w_return-id
                i_msgno                 = w_return-number
                i_msgv1                 = w_return-message_v1
                i_msgv2                 = w_return-message_v2
                i_msgv3                 = w_return-message_v3
                i_msgv4                 = w_return-message_v4
              importing
                e_msg                   = w_return-message
              tables
                et_return               = lt_return_msg
              exceptions
                msg_for_langu_not_found = 1
                others                  = 2.
            if sy-subrc <> 0.
* Implement suitable error handling here
            endif.
            wa_message-value = gv_noti_conv-qmnum.
            wa_message-message = w_return-message.
            case w_return-type.
              when 'E'.
                wa_message-mss_type = 'Error'.
              when 'W'.
                wa_message-mss_type = 'Warning'.
              when 'I'.
                wa_message-mss_type = 'Information'.
              when 'S'.
                wa_message-mss_type = 'Success'.
              when others.
                wa_message-mss_type = 'None'.
            endcase.

            append wa_message to gt_message.
            clear wa_message.
          endloop.
        else.
*        custom message class
          wa_message-mss_type = 'Success'.
          w_return-number = '000'.
          clear : w_return-message.
*        wa_message-message = 'Order has been created for Notification'.
          call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
            exporting
              i_langu                 = wa_info-lang
              i_msgid                 = gv_message_id
              i_msgno                 = w_return-number
              i_msgv1                 = w_return-message_v1
              i_msgv2                 = w_return-message_v2
              i_msgv3                 = w_return-message_v3
              i_msgv4                 = w_return-message_v4
            importing
              e_msg                   = w_return-message
            tables
              et_return               = lt_return_msg
            exceptions
              msg_for_langu_not_found = 1
              others                  = 2.
          if sy-subrc <> 0.
* Implement suitable error handling here
          endif.
          wa_message-message = w_return-message.
          wa_message-value = gv_noti_conv-qmnum.
          append wa_message to gt_message.

        endif.
      else.
*        custom message class
        wa_message-mss_type = 'Error'.
        w_return-number = '003'.
        clear : w_return-message.
*        wa_message-message = 'Order has been created for Notification'.
        call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
          exporting
            i_langu                 = wa_info-lang
            i_msgid                 = gv_message_id
            i_msgno                 = w_return-number
            i_msgv1                 = w_return-message_v1
            i_msgv2                 = w_return-message_v2
            i_msgv3                 = w_return-message_v3
            i_msgv4                 = w_return-message_v4
          importing
            e_msg                   = w_return-message
          tables
            et_return               = lt_return_msg
          exceptions
            msg_for_langu_not_found = 1
            others                  = 2.
        if sy-subrc <> 0.
* Implement suitable error handling here
        endif.
        wa_message-message = w_return-message.
        wa_message-value = gv_noti_conv-qmnum.
        append wa_message to gt_message.
      endif.
    else.
*     Create message
      loop at t_return into w_return.
        call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
          exporting
            i_langu                 = wa_info-lang
            i_msgid                 = w_return-id
            i_msgno                 = w_return-number
            i_msgv1                 = w_return-message_v1
            i_msgv2                 = w_return-message_v2
            i_msgv3                 = w_return-message_v3
            i_msgv4                 = w_return-message_v4
          importing
            e_msg                   = w_return-message
          tables
            et_return               = lt_return_msg
          exceptions
            msg_for_langu_not_found = 1
            others                  = 2.
        if sy-subrc <> 0.
* Implement suitable error handling here
        endif.
        wa_message-value = gv_noti_conv-qmnum.
        wa_message-message = w_return-message.
        case w_return-type.
          when 'E'.
            wa_message-mss_type = 'Error'.
          when 'W'.
            wa_message-mss_type = 'Warning'.
          when 'I'.
            wa_message-mss_type = 'Information'.
          when 'S'.
            wa_message-mss_type = 'Success'.
          when others.
            wa_message-mss_type = 'None'.
        endcase.

        append wa_message to gt_message.
        clear wa_message.
      endloop.
    endif.
*    endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->CREATE_TASKLIST
* +-------------------------------------------------------------------------------------------------+
* | [--->] AUFNR                          TYPE        AUFK-AUFNR(optional)
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method create_tasklist.
    data : ls_header          type eam_s_hdr_ins,
           lv_plnnr           type plnnr,
           lv_plnal           type plnal,
           lt_operations      type eam_t_tl_opr,
           lw_oper            type eam_s_tl_opr,
           order_return       type table of bapiret2,
           operations         type bapi_alm_order_operation_et,
           lw_operation       type bapi_alm_order_operation_e,
           texts              type bapi_alm_text_t,
           text_lines         type bapi_alm_text_lines_t,
           service_limit      type bapi_alm_srv_limit_data_t,
           header             type bapi_alm_order_header_e,
           lt_return          type  bapirettab,
           lw_ret             type bapiret2,
           service_limits     type eam_t_tl_spack_limits,
           task_texts         type eam_t_text,
           task_text_lines    type eam_t_text_lines,
           task_service_limit type eam_t_tl_spack_limits,
           lv_usage           type verwe value '4',
           lv_statu           type plnst value '4'.
    data : lt_info       type table of uinfo2,
           wa_info       type uinfo2,
           ln            type i,
           lt_return_msg type bapiret2_t.
    data: ls_task_operation     type eam_s_tl_opr,
          ls_task_text          type eam_s_text,
          ls_task_service_limit type eam_s_tl_spack_limit.
* Get the Logon Langu
    call function 'TH_LONG_USR_INFO'
*         EXPORTING
*           USER            = ' '
      tables
        user_info = lt_info.
    describe table lt_info lines ln.
    read table lt_info into wa_info index ln.

*   get order details
    call function 'BAPI_ALM_ORDER_GET_DETAIL'
      exporting
        number          = aufnr
      importing
        es_header       = header
      tables
        et_operations   = operations
        et_servicelimit = service_limit
        et_texts        = texts
        et_text_lines   = text_lines
        return          = order_return.

    read table gt_createtl into wa_createtl index 1.
    if wa_createtl-plnty = 'A'.
      ls_header-plnty = wa_createtl-plnty.
    elseif wa_createtl-plnty = 'T'.
      ls_header-plnty = wa_createtl-plnty.
      ls_header-tplnr = header-funct_loc.
    elseif wa_createtl-plnty = 'E'.
      ls_header-plnty = wa_createtl-plnty.
      ls_header-equnr = header-equipment.
    endif.

    ls_header-werks = header-maintplant.
    ls_header-arbpl_werk = header-plant.
    ls_header-ktext = header-short_text.
    ls_header-arbpl = wa_createtl-arbpl.
    ls_header-iwerk = header-planplant.
    ls_header-statu = lv_statu.
    ls_header-verwe = lv_usage.
    ls_header-vagrp = header-plangroup.
    ls_header-plnnr = header-task_list_group.

*  populate the operations
    loop at operations into lw_operation.
      lw_oper-plnty = wa_createtl-plnty.
      lw_oper-plnnr = header-task_list_group.
      lw_oper-vornr = lw_operation-activity.
      lw_oper-uvorn = lw_operation-sub_activity.
      lw_oper-steus = lw_operation-control_key.
      lw_oper-anlzu = lw_operation-systcond.
      lw_oper-arbpl = lw_operation-work_cntr.
      lw_oper-ltxa1 = lw_operation-description.
      lw_oper-anzzl = lw_operation-number_of_capacities.
      lw_oper-dauno = lw_operation-duration_normal.

      if lw_oper-steus = 'PM02'.
        lw_oper-bmvrg = lw_operation-quantity.
        lw_oper-bmeih = lw_operation-base_uom.
        lw_oper-matkl = lw_operation-matl_group.
        lw_oper-ekgrp = lw_operation-pur_group.
        lw_oper-ekorg = lw_operation-purch_org.
        lw_oper-lifnr = lw_operation-vendor_no.
      endif.

      "Set the cost element if found
      if lw_operation-pckg_no is not initial.
        try.
            lw_oper-sakto = service_limit[ activity = lw_operation-activity ]-cost_element.
          catch cx_sy_itab_line_not_found.
        endtry.
      endif.

      append lw_oper to lt_operations.
    endloop.

    task_service_limit = corresponding #( service_limit mapping vornr = activity ).

    modify task_service_limit from ls_task_service_limit transporting cost_element where cost_element is not initial.

    task_texts = corresponding #( texts mapping vornr = activity
                                               uvorn = sub_activity ).

    move-corresponding text_lines to task_text_lines.

*    MOVE-CORRESPONDING service_limit to service_limits.
    service_limits = CORRESPONDING #( service_limit mapping vornr = activity ).

   export lv_allow_cost_element = 'X' to memory id 'NEPTUNE_ALLOW_COST_ELEMENT'.

    call function 'EAM_TASKLIST_CREATE'
      exporting
        is_header                = ls_header
        iv_date                  = sy-datum
        iv_profile               = '0000001'
        iv_clear_buffer_if_error = 'X'
        iv_update_shorttext      = abap_true
      importing
        ev_plnnr                 = lv_plnnr
        ev_plnal                 = lv_plnal
      tables
        it_operations            = lt_operations
        it_spack_limits          = service_limits
        it_text                  = task_texts
        it_text_lines            = task_text_lines
        et_return                = lt_return.
    read table lt_return into lw_ret with key type = 'E'.
    if sy-subrc ne 0.
      call function 'EAM_TASKLIST_POST'
        exporting
          iv_plnty  = ls_header-plnty
          iv_plnnr  = lv_plnnr
        importing
          et_return = lt_return.
      if sy-subrc eq 0.
        call function 'BAPI_TRANSACTION_COMMIT'
          exporting
            wait = 'X'.

        lw_ret-number = '027'.
        call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
          exporting
            i_langu                 = wa_info-lang
            i_msgid                 = gv_message_id
            i_msgno                 = lw_ret-number
          importing
            e_msg                   = lw_ret-message
          tables
            et_return               = lt_return_msg
          exceptions
            msg_for_langu_not_found = 1
            others                  = 2.
        if sy-subrc <> 0.
* Implement suitable error handling here
        endif.
        wa_message-value = gv_ord_detail-aufnr.
        wa_message-message = lw_ret-message.
        wa_message-mss_type = 'Success'.
        append wa_message to gt_message.

      endif.
    else.
      loop at lt_return into lw_ret where type = 'E'.
        call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
          exporting
            i_langu                 = wa_info-lang
            i_msgid                 = lw_ret-id
            i_msgno                 = lw_ret-number
          importing
            e_msg                   = lw_ret-message
          tables
            et_return               = lt_return_msg
          exceptions
            msg_for_langu_not_found = 1
            others                  = 2.
        if sy-subrc <> 0.
* Implement suitable error handling here
        endif.
        wa_message-value = aufnr.
        wa_message-message = lw_ret-message.
        wa_message-mss_type = 'Error'.
        append wa_message to gt_message.
        clear wa_message.
      endloop.
    endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GENERATE_RELATION
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method generate_relation.
    types :   begin of ty_afvg.
            include type afvgb.
    types:  indold  like sy-tabix.           "Verweis auf BT_OLD
    types:     end of ty_afvg.
    data : it_index_tab type standard table of index_afvg,
           wa_index_tab like line of it_index_tab,
           ln           type i,
           t_afvg       type table of afvge,
           t_aufnr      type table of ord_pre,
           w_aufnr      type ord_pre,
           afvg_bt      type table of ty_afvg,
           afvg         type ty_afvg.
    field-symbols:
       <t_afvg>        type afvge .

    loop at gt_afvc into wa_afvc.
      move-corresponding wa_afvc to afvg.
      afvg-indold = sy-tabix.
      append afvg to afvg_bt.
    endloop.
    export afvg_bt from afvg_bt to memory id 'AFVG_BT'.
    w_aufnr-aufnr = '000062371617'.
    append w_aufnr to t_aufnr.
    break-point.
    call function 'CO_BT_AFVG_READ_ALL'
      exporting
        not_sumnr      = 'X'
        not_delete     = 'X'
      tables
        afvg_ex        = t_afvg
        aufnr_imp      = t_aufnr
      exceptions
        afvg_not_found = 1
        others         = 2.

    sort t_afvg by aufpl vornr.

    loop at t_afvg assigning <t_afvg>.
      wa_index_tab    = <t_afvg>-index.
      append wa_index_tab to it_index_tab.
    endloop.
* DESCRIBE TABLE gt_afvc lines ln.
** BREAK-POINT.
* if ln > 1.
* do ln TIMES.
*   wa_index_tab = ln.
*   append wa_index_tab to it_index_tab.
*   ln = ln - 1.
* enddo.
    sort it_index_tab.
    call function 'CO_ZF_FS_REL_CREATE'
      tables
        rel_index_tab = it_index_tab.
    if sy-subrc eq 0.

    endif.
*  endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GENERATE_RELATIONSHIPS
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method generate_relationships.
    data: lt_relations type table of bapi_alm_order_relation,
          ls_relation  type bapi_alm_order_relation,
          lt_headers   type table of bapi_alm_order_headers_i,
          ls_header    type bapi_alm_order_headers_i,
          lt_methods   type table of bapi_alm_order_method,
          ls_method    type bapi_alm_order_method,
          ls_afvc_vor  type ty_afvc,
          ls_afvc_nch  type ty_afvc,
          lt_return    type table of bapiret2,
          ls_return    type bapiret2,
          lv_refnumber type i value 0,
          lw_afab      type ty_afab,
          ls_afab_out  type ty_afab.

    check not gt_afvc[] is initial.

* Get first operation before loop.
    read table gt_afvc into ls_afvc_vor index 1.

    loop at gt_afvc into ls_afvc_nch from 2.
*   Check for existing relationship in the forward direction.
      read table gt_afab
          with key aplzl_vor = ls_afvc_vor-aplzl
                   aplzl_nch = ls_afvc_nch-aplzl
          transporting no fields.
      check sy-subrc <> 0.

*   Check for existing relationship in the reverse direction.
      read table gt_afab
          with key aplzl_vor = ls_afvc_nch-aplzl
                   aplzl_nch = ls_afvc_vor-aplzl
          transporting no fields.
      check sy-subrc <> 0.

      clear ls_afab_out.
      ls_afab_out-aufnr = ls_afvc_vor-aufnr.
      ls_afab_out-aufpl_vor = ls_afvc_vor-aufpl.
      ls_afab_out-aplzl_vor = ls_afvc_vor-aplzl.
      ls_afab_out-aufpl_nch = ls_afvc_nch-aufpl.
      ls_afab_out-aplzl_nch = ls_afvc_nch-aplzl.
      ls_afab_out-aobar     = 'FS'.
      append ls_afab_out to gt_afab.

      clear ls_relation.
      ls_relation-order_predecessor     = ls_afvc_vor-aufnr.
      ls_relation-operation_predecessor = ls_afvc_vor-vornr.
      ls_relation-order_successor       = ls_afvc_nch-aufnr.
      ls_relation-operation_successor   = ls_afvc_nch-vornr.
      ls_relation-relation_type         = 'FS'.
      ls_relation-work_cntr             = ls_afvc_vor-arbpl.
      ls_relation-plant                 = ls_afvc_vor-werks.
      append ls_relation to lt_relations.
*
      clear ls_method.
      ls_method-objecttype = 'RELATION'.
      ls_method-method     = 'CREATE'.
      ls_method-objectkey  =
          ls_afvc_vor-aufnr && ls_afvc_vor-vornr && ls_afvc_nch-aufnr && ls_afvc_nch-vornr.
      lv_refnumber = lv_refnumber + 1.
      ls_method-refnumber  = lv_refnumber.
      append ls_method to lt_methods.
    endloop.

    if not lt_relations[] is initial.
      clear ls_header.
      ls_header-orderid = ls_afvc_vor-aufnr.
      append ls_header to lt_headers.

      clear ls_method.
      ls_method-refnumber  = 1.
      ls_method-objecttype = 'HEADER'.
      ls_method-method     = 'CHANGE'.
      ls_method-objectkey  = ls_afvc_vor-aufnr.
      append ls_method to lt_methods.

      clear ls_method.
      ls_method-refnumber = 1.
      ls_method-method    = 'SAVE'.
      append ls_method to lt_methods.
    else.
      clear wa_message.
      wa_message-mss_type = 'Success'.
      wa_message-message  = 'Generation of relationships is not necessary.'.
      append wa_message to gt_message.
      return.
    endif.

    call function 'BAPI_ALM_ORDER_MAINTAIN'
      tables
        it_methods  = lt_methods
        it_header   = lt_headers
        it_relation = lt_relations
        return      = lt_return.

    commit work and wait.

    loop at lt_return into ls_return where type = 'E'.
      clear wa_message.
      wa_message-mss_type = 'Error'.
      wa_message-message  = ls_return-message.
      append wa_message to gt_message.
    endloop.

    if sy-subrc <> 0.
      clear wa_message.
      wa_message-mss_type = 'Success'.
      wa_message-message  = 'Relationships have been generated.'.
      append wa_message to gt_message.

*   Get new relationship data
*      loop at gt_afab into lw_afab.
*        clear : wa_afvc.
**  Get Relationships
*        read table et_afvc into wa_afvc with key aufpl = lw_afab-aufpl_vor
*                                                 aplzl = lw_afab-aplzl_vor.
*        if sy-subrc eq 0.
*          wa_afab-aufpl_vor = lw_afab-aufpl_vor.
*          wa_afab-aplzl_vor = wa_afvc-vornr.
*        endif.
*        clear :wa_afvc.
*        read table et_afvc into wa_afvc with key aufpl = lw_afab-aufpl_nch
*                                                 aplzl = lw_afab-aplzl_nch.
*        if sy-subrc eq 0.
*          wa_afab-aufpl_nch = lw_afab-aufpl_vor.
*          wa_afab-aplzl_nch = wa_afvc-vornr.
*        endif.
*        wa_afab-aufnr = lv_order.
*        call function 'CONVERSION_EXIT_AOBAR_OUTPUT'
*          exporting
*            input  = lw_afab-aobar
*          importing
*            output = lw_afab-aobar.
*
*        wa_afab-aobar = lw_afab-aobar.
*        wa_afab-vornc = lw_afab-vornc.
*        append wa_afab to et_afab.
*      endloop.
    endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_ASSEMBLY
* +-------------------------------------------------------------------------------------------------+
* | [--->] AJAX_VALUE                     TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method GET_ASSEMBLY.
    data: lt_hier type TABLE OF YPM_FL_HIERARCHY,
          lw_hier type YPM_FL_HIERARCHY,
          lv_aufnr type aufk-aufnr,
          lw_mtart type mara-mtart,
          lw_matnr type mara-matnr,
          lw_mapl type ty_mapl.

    lv_aufnr = ajax_value.
    call function 'YPM_SEARCH_FL_BOM'
      exporting
        iv_work_order       = lv_aufnr
      tables
        et_hierarchy        = lt_hier
              .

    loop at lt_hier into lw_hier where OBJECT_TYPE = 'M'.
      lw_matnr = lw_hier-object_number.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input         = lw_matnr
       IMPORTING
         OUTPUT        = lw_matnr
                .

      clear : lw_mtart.
      select single mtart from mara into lw_mtart
                                      where matnr = lw_matnr.
        if sy-subrc eq 0 and lw_mtart = 'IBAU'.
          lw_mapl-matnr = lw_matnr.
          lw_mapl-maktx = lw_hier-object_text.
          append lw_mapl to gt_mapl.
        endif.
    ENDLOOP.
    sort gt_mapl by matnr.
    delete ADJACENT DUPLICATES FROM gt_mapl COMPARING matnr.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_ATTACHMENTS_DATA
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_attachments_data.
    data: lv_attachment_key  type string,
          lt_attachment_keys type sorted table of string
                                 with unique key table_line,
          ls_attachment_data type ty_attachment_data,
          ls_dms_attachment  type ypm_npt_dms_attachment.

    field-symbols: <attachment_out> type ty_attachment.

* Ensure uniqueness of attachment keys so that they are
* read only once.
    loop at gt_attachments assigning <attachment_out>.
      read table lt_attachment_keys
          with key table_line = <attachment_out>-instid_b
          transporting no fields.
      if sy-subrc <> 0.
        lv_attachment_key = <attachment_out>-instid_b.
        insert lv_attachment_key into table lt_attachment_keys.
      endif.
    endloop.

* Get data for all relevant attachments.
    loop at lt_attachment_keys into lv_attachment_key.
      clear ls_attachment_data.
      ls_attachment_data-instid_b = lv_attachment_key.

      if lv_attachment_key(3) = 'DMS'.
        clear ls_dms_attachment.
        ls_dms_attachment = lv_attachment_key+3.
        ls_attachment_data-file_data = ycl_pm_npt_utilities=>get_dms_attachment_data( ls_dms_attachment ).
      else.
        call function 'YPM_GET_ATTACHMENT_DATA'
          exporting
            iv_attachment_key  = lv_attachment_key
          importing
            ev_attachment_data = ls_attachment_data-file_data.
      endif.
      append ls_attachment_data to gt_attachment_data.
    endloop.

  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_ATTACHMENTS_LIST
* +-------------------------------------------------------------------------------------------------+
* | [--->] AJAX_VALUE                     TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_attachments_list.
    data: lt_attachments_in  type table of ypm_npt_attachment,
          ls_attachment_in   type ypm_npt_attachment,
          ls_attachment_out  type ty_attachment,
          lv_work_order      type aufnr,
          lv_operation       type vornr,
          ls_attachment_data type ty_attachment_data,
          ls_attach_jobpkg   type standard table of ypmnptjobpkg,
          lw_attach          type ypmnptjobpkg,
          lw_jobpkg          type ty_jobpkg,
          iv_work_order      type aufnr,
          lt_dms_attachments type ypm_npt_dms_attachment_t,
          ls_dms_attachment  type ypm_npt_dms_attachment,
          lv_dummy           type string.

    iv_work_order = ajax_value.
    call function 'YPM_GET_WORK_ORDER_ATTACHMENTS'
      exporting
        iv_work_order  = iv_work_order
      tables
        et_attachments = lt_attachments_in.

    loop at lt_attachments_in into ls_attachment_in.
      clear ls_attachment_out.

      move-corresponding ls_attachment_in to ls_attachment_out.
      ls_attachment_out-work_order = iv_work_order.
      ls_attachment_out-keyfield   = iv_work_order && ls_attachment_out-instid_b.

      ycl_pm_npt_utilities=>get_mime_type_from_extension(
        exporting
          iv_extension       = ls_attachment_out-extension
        importing
          ev_mime_type       = ls_attachment_out-mime_type
          ev_file_icon       = ls_attachment_out-icon
          ev_file_icon_color = ls_attachment_out-icon_color
      ).

*   Add numeric sort field for grouping by origin type.
      case ls_attachment_in-origin_type.
        when 'Work Order'.
          ls_attachment_out-sort_group = 1.
        when 'Notification'.
          ls_attachment_out-sort_group = 2.
        when 'General Task'.
          ls_attachment_out-sort_group = 3.
        when 'FL Task'.
          ls_attachment_out-sort_group = 4.
        when 'EQ Task'.
          ls_attachment_out-sort_group = 5.
        when 'Functional Location'.
          ls_attachment_out-sort_group = 6.
        when 'Equipment'.
          ls_attachment_out-sort_group = 7.
        when others.
          ls_attachment_out-sort_group = 8.
      endcase.

      insert ls_attachment_out into table gt_attachments.
    endloop.

    lt_dms_attachments = ycl_pm_npt_utilities=>get_dms_attachments( iv_work_order = iv_work_order ).
    loop at lt_dms_attachments into ls_dms_attachment.
      ls_attachment_out-file_name = ls_dms_attachment-filename.
      split ls_attachment_out-file_name at '.' into lv_dummy ls_attachment_out-extension.

      ycl_pm_npt_utilities=>get_mime_type_from_extension(
        exporting
          iv_extension       = ls_attachment_out-extension
        importing
          ev_mime_type       = ls_attachment_out-mime_type
          ev_file_icon       = ls_attachment_out-icon
          ev_file_icon_color = ls_attachment_out-icon_color
      ).

      ls_attachment_out-origin_type = 'Operation (DMS)'.
      ls_attachment_out-sort_group  = 0.
      ls_attachment_out-instid_b =
          'DMS' && ls_dms_attachment-operation && ls_dms_attachment-dokar
       && ls_dms_attachment-doknr && ls_dms_attachment-dokvr && ls_dms_attachment-doktl
       && ls_dms_attachment-loio_id && ls_dms_attachment-phio_id.

      ls_attachment_out-work_order = iv_work_order.
      ls_attachment_out-keyfield   = iv_work_order && ls_attachment_out-instid_b.

      insert ls_attachment_out into table gt_attachments.
    endloop.

*    Get job Package data
    select * from ypmnptjobpkg into table ls_attach_jobpkg
                      where work_order = iv_work_order.
    loop at ls_attach_jobpkg into lw_attach.
      move-corresponding lw_attach to lw_jobpkg.

      lw_jobpkg-keyfield = lw_jobpkg-work_order && sy-tabix.
      append lw_jobpkg to gt_attach_jobpkg.
    endloop.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Private Method YCL_PM_PLANNER_CLASS->GET_CATALOGS
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_catalogs.
    refresh gt_oci_catalogs.

    gt_oci_catalogs = ycl_pm_npt_utilities=>get_all_catalogs( ).
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Private Method YCL_PM_PLANNER_CLASS->GET_CATALOG_ORDER
* +-------------------------------------------------------------------------------------------------+
* | [--->] IR_SERVER                      TYPE REF TO /NEPTUNE/CL_NAD_SERVER
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_catalog_order.
    types: begin of s_param,
             parameter(1000) type c,
           end of s_param.

    data: lv_catalog_json  type string,
          ls_material_out  type ty_resb,
          lt_oci_materials type ypm_npt_resbd_t,
          ls_oci_material  type ypm_npt_resbd,
          lx_npt_exception type ref to ycx_npt_exceptions,
          lv_posnr(4)      type n value 0.

* Retrieve stored values from OCI POST.
    ir_server->api_parameter_get(
      exporting
        name = 'OCIRETURN'
      changing
        value = lv_catalog_json
    ).

* Remove stored OCI POST info from the database.
    cl_bsp_server_side_cookie=>delete_server_cookie(
      name                  = 'OCIRETURN'
      application_namespace = '/NEPTUNE'
      application_name      = 'SERVER'
      username              = sy-uname
      session_id            = space
    ).

    lt_oci_materials = ycl_pm_npt_utilities=>process_oci_order(
      iv_oci_json   = lv_catalog_json
      iv_work_order = wa_afvc-aufnr
      iv_operation  = wa_afvc-vornr
      iv_catalog_id = wa_oci_catalog-catalog_id
    ).

    if wa_resb-posnr co '0123456789 '.
      lv_posnr = wa_resb-posnr.
    endif.

    loop at lt_oci_materials into ls_oci_material.
*      if ls_oci_material-postp = 'L'.
*        try.
*          validate_material(
*            iv_material = ls_oci_material-matnr
*            iv_plant    = wa_resb-werks
*          ).
*
*          catch ycx_npt_exceptions into lx_npt_exception.
**           TODO: Issue error to the frontend.
*        endtry.
*      endif.

      clear ls_material_out.
      move-corresponding ls_oci_material to ls_material_out.
      ls_material_out-text   = ls_oci_material-long_text.
      ls_material_out-ptext  = ls_oci_material-item_type_text.

      ls_material_out-aufnr  = wa_resb-aufnr.
      ls_material_out-vornr  = wa_resb-vornr.
      ls_material_out-rsnum  = wa_resb-rsnum.
      ls_material_out-rspos  = wa_resb-rspos.
      ls_material_out-werks  = wa_resb-werks.
      ls_material_out-posnr  = lv_posnr.
      ls_material_out-chng   = 'N'.
      ls_material_out-status = 'N'.
      ls_material_out-del_visibility = 'X'.

      ycl_pm_npt_utilities=>conversion_in( changing cv_value = ls_material_out-vornr ).

      wa_resb-rspos = wa_resb-rspos + 1.
      lv_posnr = lv_posnr + 10.

      append ls_material_out to gt_resb.
    endloop.

    wa_resb-posnr = lv_posnr.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Protected Method YCL_PM_PLANNER_CLASS->GET_CHECK_LIST
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
method GET_CHECK_LIST.
  data: lv_plant        type werks_d,
        lt_ypmnptclist  type table of ty_clist_field,
        lt_ypmnptclistt type hashed table of ypmnptclistt
                            with unique key category field_id,
        ls_ypmnptclist  type ty_clist_field,
        ls_ypmnptclistt type ypmnptclistt,
        ls_config_out   type ty_clist_field.

  refresh gt_checklist.

  select single parva into lv_plant from usr05
      where bname = sy-uname
        and parid = 'IWK'.
  if sy-subrc <> 0.
*   Can't load check list.
    return.
  endif.

* Get all configuration for the user's default plant.
  select clist~category
         clist~field_id
         clist~field_type
         clist~create_op
         clist~create_txt
         clist~std_text_key
         plnt~work_center
      into corresponding fields of table lt_ypmnptclist
      from ypmnptclist as clist
      inner join ypmnptclistplnt as plnt
          on clist~category = plnt~category
         and clist~field_id = plnt~field_id
      where plnt~plant = lv_plant
      order by clist~category clist~field_id.

* Load all configuration texts
  select * into table lt_ypmnptclistt
      from ypmnptclistt
      where language = sy-langu.
  if sy-subrc <> 0.
    select * into table lt_ypmnptclistt
        from ypmnptclistt
        where language = 'E'.
  endif.

  loop at lt_ypmnptclist into ls_ypmnptclist.
    clear ls_config_out.
    ls_config_out-category     = ls_ypmnptclist-category.
    ls_config_out-field_id     = ls_ypmnptclist-field_id.
    ls_config_out-std_text_key = ls_ypmnptclist-std_text_key.
    ls_config_out-work_center  = ls_ypmnptclist-work_center.

    if ls_ypmnptclist-create_op = 'X'.
      ls_config_out-create_op = 'true'.
    else.
      ls_config_out-create_op = 'false'.
    endif.

    if ls_ypmnptclist-create_txt = 'X'.
      ls_config_out-create_txt = 'true'.
    else.
      ls_config_out-create_txt = 'false'.
    endif.

    read table lt_ypmnptclistt into ls_ypmnptclistt
        with key category = ls_config_out-category
                 field_id = ls_config_out-field_id.
    if sy-subrc = 0.
      ls_config_out-short_text  = ls_ypmnptclistt-short_text.
      ls_config_out-description = ls_ypmnptclistt-description.
    endif.

    ls_config_out-selected = 'false'.

    append ls_config_out to gt_checklist.
  endloop.
endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_DATA
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_data.

*   Create range for Object Id based on selection
    refresh : lt_arbpl.

    split wa_default-wrk_center at ',' into table lt_arbpl.
    loop at lt_arbpl into lw_arbpl.
      rw_arbpl-low = lw_arbpl-arbpl.
      rw_arbpl-sign = 'I'.
      rw_arbpl-option = 'EQ'.
      append rw_arbpl to ra_arbpl.
    endloop.

* Select based on dates
    if wa_default-gt_range is not initial.
      split wa_default-gt_range at '-' into lv_datelow lv_datehigh.
      condense : lv_datelow,
                 lv_datehigh.
      call function 'CONVERT_DATE_TO_INTERNAL'
        exporting
          date_external            = lv_datelow
*         ACCEPT_INITIAL_DATE      =
        importing
          date_internal            = rw_date-low
        exceptions
          date_external_is_invalid = 1
          others                   = 2.
      if lv_datelow = lv_datehigh.
        rw_date-sign = 'I'.
        rw_date-option = 'EQ'.
        append rw_date to ra_date.
      else.
        call function 'CONVERT_DATE_TO_INTERNAL'
          exporting
            date_external            = lv_datehigh
          importing
            date_internal            = rw_date-high
          exceptions
            date_external_is_invalid = 1
            others                   = 2.
        rw_date-sign = 'I'.
        rw_date-option = 'BT'.
        append rw_date to ra_date.
      endif.
    endif.
*    Get planner
    if wa_default-ingpr is not INITIAL.
      rw_ingpr-low = wa_default-ingpr.
      rw_ingpr-sign = 'I'.
      rw_ingpr-option = 'EQ'.
      append rw_ingpr to ra_ingpr.
    endif.
    if ra_arbpl is not initial.
* Get Notifications
      if wa_default-noti_sel = 'X'.
        get_notifications( ).
      endif.
*    Get Orders
      if wa_default-ordr_sel = 'X' or
          wa_default-oper_sel = 'X'.
        get_orders( ).
      endif.

*   Get F4 data
      call method get_data_f4( ).
*   Reload check list data
      get_check_list( ).
    endif.




  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_DATA_F4
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_data_f4.
    data: lv_plant    type werks,
          wa_location type ty_location,
          lv_ekorg    type ekorg,
          lv_ekgrp    type ekgrp,
          lv_pernr    type pa0105-pernr,
          ra_steus    type range of t430-steus,
          rw_steus    like line of ra_steus,
          lt_dd       type table of ddshpval50,
          lw_dd       type ddshpval50,
          ra_matkl    type range of t023t-matkl,
          rw_matkl    like line of ra_matkl,
          wa_priority like line of gt_priority.


    get parameter id 'IWK' field lv_plant.

*Get Priorities (Both)
    select priok priokx
         from t356_t
         into table gt_priority
         where spras eq sy-langu
         and artpr eq 'PB'.  """"Needs More specfic condition


    loop at gt_priority into wa_priority.
      concatenate wa_priority-priok wa_priority-priokx
        into wa_priority-pri_text separated by '-'.

      modify gt_priority from wa_priority transporting pri_text.

    endloop.

    append initial line to gt_priority.
    sort gt_priority by priok.
    delete adjacent duplicates from gt_priority comparing priokx.

*  Get Notification types (Notifications)
    select a~qmart
           b~qmartx
           from tq80 as a
           inner join tq80_t as b
           on a~qmart = b~qmart
           into table gt_noti_types
           where a~qmtyp eq '01'
            and  b~spras eq sy-langu.

    append initial line to gt_noti_types.
    sort gt_noti_types by qmartx.

*  Functional Location (Both)
    select a~tplnr
           b~pltxt from
           iflot as a inner join iflotx as b
          on a~tplnr eq b~tplnr
          into table gt_location
          where a~iwerk eq lv_plant
          and a~lgwid in ra_arbpl.

    append initial line to gt_location.
    sort gt_location by pltxt.

*Conversion of Functional location
    loop at gt_location into wa_location.
      call function 'CONVERSION_EXIT_TPLNR_OUTPUT'
        exporting
          input  = wa_location-tplnr
        importing
          output = wa_location-tplnr.
      modify gt_location from wa_location transporting tplnr.
      clear wa_location.
    endloop.

*    Get Equipments (Notifications)
    select a~equnr b~eqktx
       from equz as a inner join eqkt as b
        on  a~equnr eq b~equnr
        into table gt_equipment
        where a~iwerk eq lv_plant
          and a~datbi ge sy-datum.

    append initial line to gt_equipment.
    sort gt_equipment by eqktx.

*Get PM act_type (Orders)
    select a~auart
           b~ilart
           b~ilatx into table gt_act_type
           from t350i as a inner join t353i_t as b
           on a~ilart = b~ilart
           where a~auart in ( 'MNT1', 'MNT2', 'MNT3' )
             and b~spras = sy-langu.

    append initial line to gt_act_type.
    sort gt_act_type by ilatx.

*Get revisions
    select * from t352r
        into table gt_revision
      where iwerk eq lv_plant
      and  revab eq space.

    append initial line to gt_revision.
    sort gt_revision by revnr.

* Get Purchase Orgnzation.
    get parameter id 'EKO' field lv_ekorg.
    if lv_ekorg is not initial.
      select ekorg ekotx from t024e into table gt_ekorg
                          where ekorg = lv_ekorg.
    else.
      select a~ekorg a~ekotx into table gt_ekorg
            from t024e as a inner join t024w as b
            on a~ekorg = b~ekorg where b~werks = lv_plant.
    endif.
    append initial line to gt_ekorg.
*  Get Purchase Group
    get parameter id 'EKG' field lv_ekgrp.
    if lv_ekgrp is not initial.
      select ekgrp eknam from t024 into table gt_ekgrp
                  where ekgrp = lv_ekgrp.
    else.
      select ekgrp eknam from t024 into table gt_ekgrp.
    endif.
    append initial line to gt_ekgrp.
*  Added by Nivya to get F4 help for Eternal services and Requisitions
    select * from ypmservices into table gt_external.

* Start of comment code by Nivya
*    commented the code as we are maintinaing data in custom table
*    Get Material Group
*  Material group assigned to user
*    select * from ddshpval50 into table lt_dd
*                  where username = sy-uname
*                    and pvalkey = 'H_T023'
*                    and rectype eq space.
*    if sy-subrc eq 0.
*      loop at lt_dd into lw_dd.
*        wa_matkl-matkl = lw_dd-record+0(9).
*        wa_matkl-wgbez = lw_dd-record+9(20).
*        append wa_matkl to gt_matkl.
**        Exculde material groups which are already processed
*        rw_matkl-sign = 'E'.
*        rw_matkl-option = 'EQ'.
*        rw_matkl-low = wa_matkl-matkl.
*        append rw_matkl to ra_matkl.
*      endloop.
*    endif.
*    rw_matkl-sign = 'I'.
*    rw_matkl-option = 'CP'.
*    rw_matkl-low = '0*'.
*    append rw_matkl to ra_matkl.
*    select matkl wgbez from t023t appending table gt_matkl
*                            where matkl in ra_matkl
*                              and spras eq sy-langu.
*    if sy-subrc eq 0.
*      append initial line to gt_matkl.
*      sort gt_matkl by wgbez.
*    endif.
*    end of commented code
*   Get Vendors
*  Vendors form personal list
*    select single pernr from pa0105 into
*          lv_pernr where usrid = sy-uname.
*    if lv_pernr is not initial.
*      select a~lifnr a~name1 appending table gt_lifnr
*               from lfa1 as a inner join lfb1 as b
*                on a~lifnr = b~lifnr
*                 where b~pernr = lv_pernr
*                  and a~loevm eq space.
*
*      if sy-subrc eq 0.
*
*      endif.
*    endif.
*  Vendors from Purchase Organization
    select a~lifnr a~name1 b~ekorg appending table gt_lifnr
             from lfa1 as a inner join lfm1 as b
              on a~lifnr = b~lifnr
            for all entries in gt_ekorg
              where b~ekorg = gt_ekorg-ekorg
                and b~loevm = space
                and b~sperm = space
                and a~loevm = space
                and a~sperm = space.
    if sy-subrc eq 0.
      sort gt_lifnr by lifnr ekorg.
    endif.
    append initial line to gt_lifnr.
    sort gt_lifnr by lifnr.
    delete adjacent duplicates from gt_lifnr comparing lifnr.

*    Get F4 for system conditions
    select * from t357m_t into table gt_t357m_t
                         where spras = sy-langu.


* Get control keys
  rw_steus-low = 'PM01'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

  rw_steus-low = 'PM02'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

  rw_steus-low = 'PM10'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

  rw_steus-low = 'PM99'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

  rw_steus-low = 'PMCA'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

  rw_steus-low = 'PMPC'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

  rw_steus-low = 'PMPN'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

  rw_steus-low = 'PMRW'.
  rw_steus-sign = 'I'.
  rw_steus-option = 'EQ'.
  append rw_steus to ra_steus.
  clear rw_steus.

    select a~steus b~txt into table gt_key
               from t430 as a inner join t430t as b
               on a~steus = b~steus
                   where a~steus in ra_steus
                     and b~spras eq sy-langu.
    if sy-subrc eq 0.
      loop at gt_key into wa_key.
        authority-check object 'I_AUFK_AFV'
            id 'STEUS' field wa_key-steus.
        if sy-subrc ne 0.
          delete gt_key where steus = wa_key-steus.
        endif.
      endloop.
    endif.

*    Get UOM
    select * from t006 into TABLE gt_uom.

*   Get curr key
    select * from tcurc into TABLE gt_curr.

*  Get standard text keys
    select t435t~VLSCH t435t~TXT from t435 INNER JOIN t435t on
                  t435~VLSCH = t435t~VLSCH into TABLE gt_t435
                    where t435t~spras = sy-langu.

  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_EQUIPMENT_HISTORY
* +-------------------------------------------------------------------------------------------------+
* | [--->] IV_WORK_ORDER                  TYPE        AUFNR
* | [<---] ET_TECH_HIST                   TYPE        T_TECH
* | [<---] ET_ACT_HIST                    TYPE        T_ACT
* | [<---] ET_RESB_HIST                   TYPE        T_RESB
* | [<---] ET_EQUI                        TYPE        T_EQUI
* | [<---] ET_ATTACH                      TYPE        T_ACTT
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_equipment_history.
    data : lt_items  type table of bapi2080_notiteme,
           lw_items  type bapi2080_notiteme,
           lt_caus   type table of bapi2080_notcause,
           lw_caus   type bapi2080_notcause,
           lt_act    type table of bapi2080_notactve,
           lw_act    type bapi2080_notactve,
           lt_resb   type table of ty_resb,
           lw_resb   type ty_resb,
           lv_seqnr  type i,
           lt_return type table of bapiret2,
           lt_t418t  type table of t418t,
           lw_t418t  type t418t,
           lv_order type string,
           lv_tplnr  type tplnr.

    refresh: et_tech_hist,
             et_act_hist,
             et_resb_hist,
             et_equi.

    field-symbols: <equi> type ty_equi,
                   <resb> type ty_resb,
                   <tech> type ty_tech,
                   <act>  type ty_act.

*   1/8/2018 - Get history from FL if Equipment is not populated.
    select single afih~equnr iloa~tplnr
        into (gv_ord_detail-equnr,lv_tplnr)
        from afih
        inner join iloa on afih~iloan = iloa~iloan
        where afih~aufnr = iv_work_order.

    check sy-subrc = 0.

    if not gv_ord_detail-equnr is initial.
      select qmnum equnr qmtxt aufnr qmdab up to 10 rows
               into table et_equi from viqmel
              where equnr = gv_ord_detail-equnr
                order by qmdat descending.
    elseif not lv_tplnr is initial.
      select qmnum equnr qmtxt aufnr qmdab up to 10 rows
               into table et_equi from viqmel
              where tplnr = lv_tplnr
                order by qmdat descending.
    else.
      return.
    endif.

    if sy-subrc eq 0.
      loop at et_equi into wa_equi.
        refresh : lt_items,
                  lt_caus,
                  lt_act,
                  lt_return.

*        Get Notification details
        if wa_equi-qmnum is not initial.
          call function 'BAPI_ALM_NOTIF_GET_DETAIL'
            exporting
              number    = wa_equi-qmnum
            tables
              notitem   = lt_items
              notifcaus = lt_caus
              notifactv = lt_act
              return    = lt_return.
          if sy-subrc eq 0.
            loop at lt_items into lw_items.
*         Pass items detail
              wa_tech_hist-qmnum = lw_items-notif_no.
              wa_tech_hist-fenum = lw_items-item_key.
              wa_tech_hist-fetxt = lw_items-descript.
              wa_tech_hist-otgrp = lw_items-dl_codegrp.
              wa_tech_hist-oteil = lw_items-dl_code.
              wa_tech_hist-fegrp = lw_items-d_codegrp.
              wa_tech_hist-fecod = lw_items-d_code.
              wa_tech_hist-obj_text = lw_items-txt_objptcd.
              wa_tech_hist-dam_text = lw_items-txt_probcd.
              wa_tech_hist-bautl = lw_items-assembly.
              wa_tech_hist-maktx = lw_items-txt_part.
*      Get long text for items/Causes and activites
              wa_head-tdid = 'LTXT'.
              wa_head-tdobject = 'QMFE'.
              wa_head-tdspras = sy-langu.
              concatenate wa_tech_hist-qmnum wa_tech_hist-fenum
                      into wa_head-tdname.
*     Read Item Text
              call method read_text
                exporting
                  wa_head = wa_head
                importing
                  text    = wa_tech_hist-itm_text.
*    Rad Cause details for an item
              clear : lw_caus,
                      wa_head.
              read table lt_caus into lw_caus
                            with key notif_no = lw_items-notif_no
                                     item_key = lw_items-item_key.
              if sy-subrc eq 0.
                wa_tech_hist-urgrp = lw_caus-cause_codegrp.
                wa_tech_hist-urcod = lw_caus-cause_code.
                wa_tech_hist-urtxt = lw_caus-causetext.
                wa_tech_hist-qurnum = lw_caus-cause_sort_no.
                wa_tech_hist-cus_text = lw_caus-txt_causecd.
*         Read Cause Text
                clear : wa_head.
                wa_head-tdid = 'LTXT'.
                wa_head-tdobject = 'QMUR'.
                wa_head-tdspras = sy-langu.
                concatenate wa_tech_hist-qmnum wa_tech_hist-fenum wa_tech_hist-qurnum
                        into wa_head-tdname.
                call method read_text
                  exporting
                    wa_head = wa_head
                  importing
                    text    = wa_tech_hist-cau_text.
              endif.
*    Read activity details for an item
              clear : lw_act.
              read table lt_act into lw_act
                        with key notif_no = lw_items-notif_no
                                 item_key = lw_items-item_key.
              if sy-subrc eq 0.
                wa_tech_hist-manum = lw_act-act_key.
                wa_tech_hist-mngrp = lw_act-act_codegrp.
                wa_tech_hist-mncod = lw_act-act_code.
                wa_tech_hist-atv_text = lw_act-txt_actcd.
*    Read activity text
                clear : wa_head.
                wa_head-tdid = 'LTXT'.
                wa_head-tdobject = 'QMMA'.
                wa_head-tdspras = sy-langu.
                concatenate wa_tech_hist-qmnum wa_tech_hist-manum
                        into wa_head-tdname.
                call method read_text
                  exporting
                    wa_head = wa_head
                  importing
                    text    = wa_tech_hist-act_text.
              endif.
              append wa_tech_hist to et_tech_hist.

            endloop.
*   Get individual activites.
            clear : lw_act.
            loop at lt_act into lw_act where item_key is initial.
              wa_act_hist-qmnum = lw_act-notif_no.
              wa_act_hist-manum = lw_act-act_key.
              wa_act_hist-mngrp = lw_act-act_codegrp.
              wa_act_hist-mncod = lw_act-act_code.
              wa_act_hist-matxt = lw_act-acttext.
              wa_act_hist-atv_text = lw_act-txt_actcd.
*  Read activity text
              clear : wa_head.
              wa_head-tdid = 'LTXT'.
              wa_head-tdobject = 'QMMA'.
              wa_head-tdspras = sy-langu.
              concatenate wa_tech_hist-qmnum wa_tech_hist-manum
                      into wa_head-tdname.
              call method read_text
                exporting
                  wa_head = wa_head
                importing
                  text    = wa_act_hist-act_text.
              append wa_act_hist to et_act_hist.
            endloop.
          endif.
        endif.
        if wa_equi-aufnr is not initial.
          select aufnr
                 rsnum
                 rspos
                 matnr
                 werks
                 bdmng
                 meins
                 enmng
                 postp
                 posnr
                 potx1
                 vornr into CORRESPONDING FIELDS OF table lt_resb from resb
                      where aufnr = wa_equi-aufnr
                         and xloek eq space.
          if sy-subrc eq 0.
*           Get text item descriptions
            select * from t418t into table lt_t418t
                          for all entries in lt_resb
                              where spras = sy-langu
                                and postp = lt_resb-postp.

            loop at lt_resb into lw_resb.
              move-corresponding lw_resb to wa_resb_hist.
*                Get material description
              if lw_resb-matnr is not initial.
                select single maktx into lw_resb-potx1 from makt
                                         where matnr = lw_resb-matnr
                                           and spras = sy-langu.
                if sy-subrc eq 0.
                  wa_resb_hist-potx1 = lw_resb-potx1.
                endif.
              endif.
*             Get long text for the order
              clear : wa_head.
              concatenate sy-mandt lw_resb-rsnum lw_resb-rspos
                        into wa_head-tdname.
              wa_head-tdid = 'MATK'.
              wa_head-tdobject = 'AUFK'.
              wa_head-tdspras = sy-langu.
              call method read_text
                exporting
                  wa_head = wa_head
                importing
                  text    = lw_resb-text.
              wa_resb_hist-text = lw_resb-text.

*             Get item text description
              read table lt_t418t into lw_t418t
                    with key postp = wa_resb_hist-postp.
              if sy-subrc eq 0.
                wa_resb_hist-ptext = lw_t418t-ptext.
              endif.

              append wa_resb_hist to et_resb_hist.
            endloop.
          endif.
        endif.
*    check for order number
        if wa_equi-aufnr is not INITIAL.
          lv_order = wa_equi-aufnr.
           get_attachments_list( lv_order ).
        ENDIF.
      endloop.
      sort gt_attachments by work_order sort_group file_name.
    endif.


*   Set key fields for AppDB.
    loop at et_equi assigning <equi>.
      <equi>-work_order = iv_work_order.
      write sy-tabix to <equi>-seqnr left-justified.
      <equi>-keyfield = iv_work_order && <equi>-seqnr.
    endloop.

    loop at et_tech_hist assigning <tech>.
      <tech>-notification = <tech>-qmnum.
      <tech>-keyfield     = <tech>-qmnum && <tech>-fenum.
    endloop.

    loop at et_act_hist assigning <act>.
      <act>-notification = <act>-qmnum.
      <act>-keyfield     = <act>-qmnum && <act>-manum.
    endloop.

    loop at et_resb_hist assigning <resb>.
      <resb>-keyfield = <resb>-aufnr && <resb>-vornr && <resb>-rspos.
    endloop.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_GENERAL_TASKLIST
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_general_tasklist.
    data: ra_ktext type range of plko-ktext,
          rw_ktext like line of ra_ktext,
          ra_vagrp type range of plko-vagrp,
          rw_vagrp like line of ra_vagrp,
          ra_istru type range of plko-istru,
          rw_istru like line of ra_istru.
*      Get General task Lists
    if gv_search_tasks-ktext is not initial.
      rw_ktext-option = 'CP'.
      rw_ktext-low = gv_search_tasks-ktext && '*'.
      rw_ktext-sign = 'I'.
      append rw_ktext to ra_ktext.
    endif.
    if gv_search_tasks-vagrp is not initial.
      rw_vagrp-option = 'EQ'.
      rw_vagrp-low = gv_search_tasks-vagrp.
      rw_vagrp-sign = 'I'.
      append rw_vagrp to ra_vagrp.
    endif.
    if gv_search_tasks-istru is not initial.
      rw_istru-option = 'EQ'.
      rw_istru-low = gv_search_tasks-istru.
      rw_istru-sign = 'I'.
      append rw_istru to ra_istru.
    endif.
    refresh : gt_plko.
    select single objid from crhd into wa_plko-arbid
                             where arbpl = gv_search_tasks-arbpl
                               and werks = gv_search_tasks-werks.
    select plnty plnnr plnal zaehl datuv verwe werks
           statu vagrp ktext txtsp istru arbid  from plko
                    into table gt_plko where plnty = 'A'
                                        and statu in ( '2', '4', '5' )
                                        and datuv le gv_ord_detail-gstrp
                                        and arbid = wa_plko-arbid
                                        and ktext in ra_ktext
                                        and vagrp in ra_vagrp
                                        and istru in ra_istru
                                        and werks = gv_search_tasks-werks.

    loop at gt_plko into wa_plko.
      wa_plko-keyfield = wa_plko-plnty && wa_plko-plnnr &&
                           wa_plko-plnal && wa_plko-zaehl.
      wa_plko-arbpl = gv_ord_detail-vaplz.
      modify gt_plko from wa_plko.
    endloop.
    sort gt_plko by plnnr plnal.
*    get all operations for general task list
    if gt_plko[] is not initial.
      select a~plnty a~plnnr a~zaehl a~arbid a~ltxa1 a~dauno a~arbei a~anzzl
                        b~plnal from plpo as a INNER JOIN plas as b
                         on a~plnnr = b~plnnr and a~plnkn = b~plnkn
                      into table gt_plpo for all entries in gt_plko
                                where a~plnty = 'A'
                                  and a~plnnr = gt_plko-plnnr
*                                  and datuv ge gt_plko-datuv
                                  and b~plnal = gt_plko-plnal.
        if sy-subrc eq 0.
          sort gt_plpo by plnnr plnal.
          loop at gt_plpo into wa_plpo.
            select single arbpl into wa_plpo-arbpl from crhd
                                    where objid = wa_plpo-arbid
                                      and objty = 'A'.
              if sy-subrc eq 0.
                modify gt_plpo from wa_plpo.
              endif.
          ENDLOOP.
          sort gt_plpo by plnnr plnal zaehl.
        endif.

    endif.

  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_NOTIFICATIONS
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_notifications.

    types: begin of s_stat,
             objnr type j_objnr,
             stat  type j_status,
           end of s_stat.

    data :ra_stat        type range of jest-stat,
          rw_stat        like line of ra_stat,
          ra_beber       type range of t357-beber,
          rw_beber       like line of ra_beber,
          lv_aufnr       type string,
          lw_noti_detail type ty_noti_detail,
          c_qmdab        type qmel-qmdab value is initial,
          lt_stat        type hashed table of s_stat
                      with unique key objnr stat.

*    split wa_default-wrk_center at ',' into table lt_arbpl.
*    loop at lt_arbpl into lw_arbpl.
*      rw_arbpl-low = lw_arbpl-arbpl.
*      rw_arbpl-sign = 'I'.
*      rw_arbpl-option = 'EQ'.
*      append rw_arbpl to ra_arbpl.
*    endloop.
    if wa_default-beber is not initial.
      rw_beber-low = wa_default-beber.
      rw_beber-sign = 'I'.
      rw_beber-option = 'EQ'.
      append rw_beber to ra_beber.
    endif.

    select qmnum qmart qmtxt priok erdat aufnr objnr into table gt_notiflist
                      from viqmel
                       where arbpl in ra_arbpl
                         and qmdab eq c_qmdab
                         and ingrp in ra_ingpr
                         and beber in ra_beber
                         and aufnr eq space
                         and erdat in ra_date.

    if sy-subrc eq 0 and not gt_notiflist[] is initial.
      select objnr stat into table lt_stat
          from jest
          for all entries in gt_notiflist
          where objnr = gt_notiflist-objnr
            and inact = space.

      loop at gt_notiflist into wa_notilist.
        clear : lv_aufnr.
        lv_aufnr = wa_notilist-qmnum.
        call function 'AIP9_STATUS_READ'
          exporting
            i_objnr = wa_notilist-objnr
          importing
            e_sysst = wa_notilist-stat.

*        case wa_notilist-stat.
*          when 'MOBI ONSO'.
*            wa_notilist-stat_text = 'Outstanding'.
*            wa_notilist-stat_color = 'Error'.
*          when 'NOPR'.
*            wa_notilist-stat_text = 'In Progress'.
*            wa_notilist-stat_color = 'Warning'.
*          when 'ORAS'.
*            wa_notilist-stat_text = 'Assigned'.
*            wa_notilist-stat_color = 'Success'.
*          when others.
*            wa_notilist-stat_color = 'None'.
*        endcase.

*       2/1/2018 - remove rejected notifications.
        read table lt_stat
            with key objnr = wa_notilist-objnr
                      stat = 'E0027' "REJT
            transporting no fields.
        if sy-subrc = 0.
          delete gt_notiflist.
          continue.
        endif.

        if wa_notilist-stat cs 'DLFL' or wa_notilist-stat cs 'NOCO'.
          delete gt_notiflist where qmnum = wa_notilist-qmnum.
          continue.
        endif.
        wa_notilist-offline_state = 'None'.
*      2/12/18  Get Notification detail
        call method me->get_notification_details
          exporting
            ajax_value     = lv_aufnr
          importing
            gv_noti_detail = lw_noti_detail.
        wa_notilist-tplnr = lw_noti_detail-tplnr .
        wa_notilist-equnr = lw_noti_detail-equnr.
        wa_notilist-floc_text = lw_noti_detail-floc_text .
        wa_notilist-equi_text = lw_noti_detail-equi_text.
        wa_notilist-usrstatus = lw_noti_detail-usrstatus.

        concatenate wa_notilist-qmnum wa_notilist-qmart
          into wa_notilist-notistat separated by '-'.
        concatenate wa_notilist-qmnum wa_notilist-qmtxt
          wa_notilist-tplnr wa_notilist-floc_text
          wa_notilist-equi_text into wa_notilist-search
          separated by space.
        modify gt_notiflist from wa_notilist.
      endloop.
    endif.



  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_NOTIFICATION_DETAILS
* +-------------------------------------------------------------------------------------------------+
* | [--->] AJAX_VALUE                     TYPE        STRING
* | [<---] GV_NOTI_DETAIL                 TYPE        TY_NOTI_DETAIL
* | [<---] ET_TJ30T_NOTIF                 TYPE        T_TJ30T
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_notification_details.

    types: begin of s_stat,
             stat  type j_estat,
             txt04 type j_txt04,
             txt30 type j_txt30,
           end of s_stat.

    data: wa_noti_detail type ty_noti_detail,
          lv_iloan       type qmih-iloan,
          lv_objtyp      type jsto-obtyp,
          lv_stsma       type jsto-stsma,
          lv_stonr       type tj30-stonr,
          lv_txt04       type tj30t-txt04,
          ls_tj30t       type ty_tj30t,
          lt_status      type hashed table of s_stat
                             with unique key stat,
          ls_status      type s_stat,
          lt_notif_stat  type table of j_estat,
          lv_notif_stat  type j_estat.

    select single qmnum
                  qmart
                  priok
                  qmtxt
                  ingrp
                  arbpl
                  arbplwerk
                  equnr
                  tplnr
                  objnr
                  from viqmel into corresponding fields of wa_noti_detail
                  where qmnum eq ajax_value.

* get notification desc.
    select single qmartx from tq80_t
      into wa_noti_detail-qmartx
      where qmart eq wa_noti_detail-qmart
      and spras eq sy-langu.
* Get planner group description
      select single innam from t024i
        into wa_noti_detail-ingrp_text
         where iwerk = wa_noti_detail-arbplwerk
          and  ingrp = wa_noti_detail-ingrp.
* Work center additional info
    select single crhd~arbpl
                 crtx~ktext
        into ( wa_noti_detail-arbpl2, wa_noti_detail-arbpl2_txt )
        from crhd
        inner join crtx on crhd~objid = crtx~objid
          where crhd~objid eq wa_noti_detail-arbpl
          and crtx~spras = 'E'.

*    Texts
    select single pltxt from iflotx into  wa_noti_detail-floc_text
      where tplnr eq wa_noti_detail-tplnr
      and spras eq sy-langu.

    select single eqktx from eqkt into wa_noti_detail-equi_text
      where equnr eq wa_noti_detail-equnr
      and spras eq sy-langu.

    select single priokx
       from t356_t
       into wa_noti_detail-pri_text
       where spras eq sy-langu
       and artpr eq 'PB'
      and priok eq wa_noti_detail-priok.

*Functional location
    call function 'CONVERSION_EXIT_TPLNR_OUTPUT'
      exporting
        input  = wa_noti_detail-tplnr
      importing
        output = wa_noti_detail-tplnr.

    clear: wa_location,
           wa_equipment.
*Long Text
    wa_head-tdname = ajax_value.
    wa_head-tdid = 'LTXT'.
    wa_head-tdobject = 'QMEL'.
    wa_head-tdspras = sy-langu.

    call method me->read_text
      exporting
        wa_head = wa_head
       iv_preserve_formatting = ABAP_TRUE
      importing
        text    = wa_noti_detail-lg_text_n.

*   All non-numbered user statuses in the profile.
    select single stsma into lv_stsma from jsto
        where objnr = wa_noti_detail-objnr.

    select tj30~estat tj30t~txt04 tj30t~txt30 into table lt_status
        from tj30
        inner join tj30t on tj30~stsma = tj30t~stsma
                        and tj30~estat = tj30t~estat
        where tj30~stsma = lv_stsma
          and tj30~stonr = 0
          and tj30t~spras = sy-langu.

*   All non-numbered active user statuses on the notification.
    select stat into table lt_notif_stat
        from jest
        where objnr = wa_noti_detail-objnr
          and inact = space.

    loop at lt_notif_stat into lv_notif_stat.
      read table lt_status into ls_status
          with key stat = lv_notif_stat.
      check sy-subrc = 0.

      if wa_noti_detail-usrstatus is initial.
        wa_noti_detail-usrstatus = ls_status-txt04.
      else.
        concatenate wa_noti_detail-usrstatus ls_status-txt04
             into wa_noti_detail-usrstatus separated by space.
      endif.
    endloop.

*   Get F4 help for user Status
    loop at lt_status into ls_status.
      clear ls_tj30t.
      ls_tj30t-qmnum = wa_noti_detail-qmnum.
      ls_tj30t-estat = ls_status-stat.
      ls_tj30t-txt04 = ls_status-txt04.
      ls_tj30t-txt30 = ls_status-txt30.
      append ls_tj30t to et_tj30t_notif.
    endloop.

    sort et_tj30t_notif by qmnum txt30.

    move-corresponding wa_noti_detail to gv_noti_detail.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_OPERATIONS
* +-------------------------------------------------------------------------------------------------+
* | [--->] AJAX_VALUE                     TYPE        STRING
* | [<---] ET_RESB                        TYPE        T_RESB
* | [<---] ET_AFVC                        TYPE        T_AFVC
* | [<---] ET_AFAB                        TYPE        T_AFAB
* | [<---] ET_ALL_AFVC                    TYPE        T_ALL_AFVC
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_operations.
    data : lv_order  type aufk-aufnr,
           lt_status type table of jstat,
           lw_status type jstat,
           lw_stsma  type jsto-stsma,
           lv_txt04  type tj30t-txt04,
           lt_afab   type table of afab,
           lw_afab   type afab,
           lt_makt   type table of makt,
           lw_makt   type makt,
           lt_t418t  type table of t418t,
           lw_t418t  type t418t,
           lv_resb   type table of ty_resb,
           lw_resb   type ty_resb,
           lw_afvc   type ty_afvc,
           lw_all_afvc type ty_all_afvc,
           index     type i,
           ln        type i.

    lv_order = ajax_value.
* Get Operations for an order

    select b~aufnr
           a~aufpl
           a~aplzl
           a~vornr
           a~anzzl
           a~arbid
           a~ltxa1
           a~steus
           a~tplnr
           a~equnr
           a~objnr
           a~arbid
           a~matkl
           a~ekorg
           a~ekgrp
           a~afnam
           a~wempf
           a~lifnr
           a~ablad
           a~bednr
           a~anlzu
           a~ktsch
           a~plnnr
           a~packno into corresponding fields of table et_afvc from
           afvc as a inner join afko as b
           on a~aufpl = b~aufpl
                    where b~aufnr = lv_order
                      and a~loekz eq space
                      and a~phflg eq space.
    if sy-subrc eq 0.
      describe table et_afvc lines ln.
      tot_count = ln * 4.
*    Get hours
      select aufpl aplzl arbei arbeh ismnw dauno
       from afvv
       into table gt_afvv
       for all entries in et_afvc
       where aufpl eq et_afvc-aufpl
         and aplzl eq et_afvc-aplzl.
      if sy-subrc eq 0.
        sort gt_afvv by aufpl aplzl.
      endif.
*  Get relationships
      select * from afab into table lt_afab
                  for all entries in et_afvc
                      where aufpl_vor = et_afvc-aufpl
                       and aobar in ( 'NF', 'AF' ).
      if sy-subrc eq 0.
        sort lt_afab.
      endif.
* Get Enhancement Data
      select aufpl aplzl usr00 usr01 usr02 usr09
      from afvu into table gt_afvu
        for all entries in et_afvc
        where aufpl = et_afvc-aufpl
          and aplzl = et_afvc-aplzl.
      if sy-subrc eq 0.
        sort gt_afvu by aufpl aplzl.
      endif.

*  Get parts for the operations
      select aufnr
             rsnum
             rspos
             matnr
             werks
             bdmng
             meins
             enmng
             postp
             posnr
             potx1
             vornr
             saknr
             ekgrp
             lifnr
             bdter
             matkl
             wempf
             ablad
             gpreis
             waers
              into corresponding fields of table et_resb from resb
               for all entries in et_afvc
                    where aufnr = et_afvc-aufnr
                       and vornr = et_afvc-vornr
                       and xloek eq space.
      if sy-subrc eq 0.
        sort et_resb by rsnum rspos.

*         Get MAKTX
        select *
               from makt
               into table lt_makt
               for all entries in et_resb
               where spras eq sy-langu
                 and matnr eq et_resb-matnr.
        if sy-subrc eq 0.
          sort lt_makt by matnr.
        endif.
*   Get text item descriptions
        select * from t418t into table lt_t418t
                      for all entries in et_resb
                          where spras = sy-langu
                            and postp = et_resb-postp.
      endif.
      clear: index.
      loop at et_afvc into wa_afvc.
*    Read long text for operation
        clear wa_head.
        wa_head-tdname   = sy-mandt && wa_afvc-aufpl && wa_afvc-aplzl.
        wa_head-tdid     = 'AVOT'.
        wa_head-tdobject = 'AUFK'.
        wa_head-tdspras  = sy-langu.
        read_text(
          exporting
            wa_head                = wa_head
            iv_preserve_formatting = abap_true
          importing
            text                   = wa_afvc-text
        ).

*       D.Rempe - 1/8/2018 - Default short text into long text field,
*                 like SAP does in IW32.
        if wa_afvc-text is initial.
          wa_afvc-text = wa_afvc-ltxa1.
*          wa_afvc-lng_text = 'false'.
        else.
          wa_afvc-lng_text = 'true'.
        endif.

*    Get Hours entered in the operation
        read table gt_afvv into wa_afvv with key aufpl = wa_afvc-aufpl
                                            aplzl = wa_afvc-aplzl
                                            binary search.
        if sy-subrc eq 0.
          wa_afvc-arbei = wa_afvv-arbei.
          wa_afvc-arbeh = wa_afvv-arbeh.
          wa_afvc-ismnw = wa_afvv-ismnw.
          wa_afvc-dauno = wa_afvv-dauno.
        endif.
*    Get Enhancment tab data
        read table gt_afvu into wa_afvu with key aufpl = wa_afvc-aufpl
                                                 aplzl = wa_afvc-aplzl
                                                 binary search.
        if sy-subrc eq 0.
          wa_afvc-usr00 = wa_afvu-usr00.
          wa_afvc-usr01 = wa_afvu-usr01.
          wa_afvc-usr02 = wa_afvu-usr02.
          if wa_afvu-usr09 is not INITIAL.
            wa_afvc-usr09 = wa_afvu-usr09.
          endif.

        endif.
*        get work center
        select single arbpl from crhd into wa_afvc-arbpl
                    where objty = 'A'
                      and objid = wa_afvc-arbid.
*        Get user status
        if wa_afvc-objnr is not initial.
          clear : lw_stsma,
                  wa_afvc-status.
          refresh : lt_status.
          call function 'AIP9_STATUS_READ'
            exporting
              i_objnr = wa_afvc-objnr
            importing
              e_sysst = wa_afvc-status.
          call function 'STATUS_READ'
            exporting
*             CLIENT           = SY-MANDT
              objnr            = wa_afvc-objnr
              only_active      = 'X'
            importing
              stsma            = lw_stsma
            tables
              status           = lt_status
            exceptions
              object_not_found = 1
              others           = 2.
          clear : ln.
          loop at lt_status into lw_status where stat ca 'E'.
            select single txt04 from tj30t into lv_txt04
                                where stsma = lw_stsma
                                  and estat = lw_status-stat.
            if sy-subrc eq 0.
              if sy-tabix eq 1.
                wa_afvc-usrst = lv_txt04.
              else.
                concatenate wa_afvc-usrst lv_txt04
                     into wa_afvc-usrst separated by space.
              endif.
              if lw_status-stat = 'E0012'. "No planning
                wa_afvc-npln = 'true'.
                ln = count.
              endif.
              if lw_status-stat = 'E0027'. "Estimated hours
                wa_afvc-esth = 'true'.
                count = count + 1.
              endif.
              if lw_status-stat = 'E0028'. "Detial/ instructions
                wa_afvc-detc = 'true'.
                count = count + 1.
              endif.
              if lw_status-stat = 'E0029'. "parts/ materials ordered
                wa_afvc-prto = 'true'.
                count = count + 1.
              endif.
              if lw_status-stat = 'E0030'. "job package
                wa_afvc-jbpk = 'true'.
                count = count + 1.
              endif.
*      wa_afvc-usrst = lw_status-stat.
            endif.
          endloop.
        endif.
        if wa_afvc-esth = 't' and
           wa_afvc-detc = 't' and
           wa_afvc-prto = 't' and
          wa_afvc-jbpk = 't'.
          wa_afvc-color = 'green'.
        elseif wa_afvc-esth is initial and
           wa_afvc-detc is initial and
           wa_afvc-prto is initial and
          wa_afvc-jbpk is initial.
          wa_afvc-color = 'red'.
        else.
          wa_afvc-color = 'yellow'.
        endif.
        if wa_afvc-npln = 't'.
          wa_afvc-color = 'green'.
          tot_count = tot_count - 4.
          count = ln.
        endif.
*        get service limits
        if wa_afvc-packno is not initial.
          select single commitment kstar from esuh into
                        (wa_afvc-commitment, wa_afvc-sakto)
                        where packno = wa_afvc-packno.

        endif.
*     Relation ship
        loop at lt_afab into lw_afab where aufpl_vor = wa_afvc-aufpl
                                        and aplzl_vor = wa_afvc-aplzl.
*        clear : wa_afvc.
*    Get Relationships
*        read table et_afvc into wa_afvc with key aufpl = lw_afab-aufpl_vor
*                                                 aplzl = lw_afab-aplzl_vor.
*        if sy-subrc eq 0.
          wa_afab-aufpl_vor = lw_afab-aufpl_vor.
          wa_afab-aplzl_vor = wa_afvc-vornr.
          wa_afab-opertxt = wa_afvc-ltxa1.
          wa_afab-arbpl = wa_afvc-arbpl.
*        endif.
*        clear :wa_afvc.
          read table et_afvc into lw_afvc with key aufpl = lw_afab-aufpl_nch
                                                   aplzl = lw_afab-aplzl_nch.
          if sy-subrc eq 0.
            wa_afab-aufpl_nch = lw_afvc-aufpl.
            wa_afab-aplzl_nch = lw_afvc-vornr.
            wa_afab-aplzl_vornr = lw_afab-aplzl_vor.
          endif.
          wa_afab-aufnr = wa_afvc-aufnr.
          call function 'CONVERSION_EXIT_AOBAR_OUTPUT'
            exporting
              input  = lw_afab-aobar
            importing
              output = lw_afab-aobar.

          wa_afab-aobar = lw_afab-aobar.
          wa_afab-vornc = lw_afab-vornc.
          append wa_afab to et_afab.
          clear : wa_afab.
        endloop.
*        if sy-subrc ne 0.
*          wa_afab-aufpl_vor = wa_afvc-aufpl.
*          wa_afab-aplzl_vor = wa_afvc-vornr.
*          wa_afab-aufpl_nch = wa_afvc-aufpl.
*          wa_afab-opertxt = wa_afvc-ltxa1.
*          wa_afab-arbpl = wa_afvc-arbpl.
*          wa_afab-aufnr = wa_afvc-aufnr.
*          append wa_afab to et_afab.
*          clear : wa_afab.
*        endif.
        concatenate gv_ord_detail-ktext '-' wa_afvc-ltxa1
                    into wa_afvc-text_oper separated by space.
        wa_afvc-keyfield = wa_afvc-aufpl && wa_afvc-aplzl.
*        pass the index number for highlighting
        index = index + 1.
        wa_afvc-ind = index.
        modify et_afvc from wa_afvc.
        clear : wa_afvc.
      endloop.
*      Parts long text
      loop at et_resb into wa_resb.
*      get material text
        read table lt_makt into lw_makt
            with key matnr = wa_resb-matnr.
        if sy-subrc eq 0.
          wa_resb-potx1 = lw_makt-maktx.
        endif.
*     Get item text description
        read table lt_t418t into lw_t418t
              with key postp = wa_resb-postp.
        if sy-subrc eq 0.
          wa_resb-ptext = lw_t418t-ptext.
        endif.
*    Long text display
        concatenate sy-mandt wa_resb-rsnum wa_resb-rspos
                               into wa_head-tdname.
        wa_head-tdid = 'MATK'.
        wa_head-tdobject = 'AUFK'.
        wa_head-tdspras = sy-langu.
        call method read_text
          exporting
            wa_head                = wa_head
            iv_preserve_formatting = abap_true
          importing
            text                   = wa_resb-text.
*      wa_resb-edit_visibilty = '""'.
*      wa_resb-del_visibility = '"'.
        if wa_resb-text is not initial.
          wa_resb-lng_text = 'true'.
        endif.
*        get purchasing data
        select single afnam ekorg from rsadd into ( wa_resb-afnam, wa_resb-ekorg )
                          where RSNUM = wa_resb-rsnum
                            and RSPOS = wa_resb-rspos.
*     Set key field for AppDB.
        wa_resb-keyfield = wa_resb-aufnr && wa_resb-vornr && wa_resb-rspos.

        modify et_resb from wa_resb.
      endloop.

*      get all operations data including deletions
      READ TABLE et_afvc into wa_afvc index 1.
      select aplzl vornr  from afvc into CORRESPONDING FIELDS OF
            table et_all_afvc where aufpl = wa_afvc-aufpl.
        loop at et_all_afvc into lw_all_afvc.
          lw_all_afvc-aufnr = lv_order.
          lw_all_afvc-key = lw_all_afvc-aufnr && lw_all_afvc-vornr.
          modify et_all_afvc from lw_all_afvc.
        ENDLOOP.
      clear : wa_afvc.
*      loop at lt_afab into lw_afab.
*        clear : wa_afvc.
**    Get Relationships
*        read table et_afvc into wa_afvc with key aufpl = lw_afab-aufpl_vor
*                                                 aplzl = lw_afab-aplzl_vor.
*        if sy-subrc eq 0.
*          wa_afab-aufpl_vor = lw_afab-aufpl_vor.
*          wa_afab-aplzl_vor = wa_afvc-vornr.
*          wa_afab-opertxt = wa_afvc-ltxa1.
*          wa_afab-arbpl = wa_afvc-arbpl.
*        endif.
*        clear :wa_afvc.
*        read table et_afvc into wa_afvc with key aufpl = lw_afab-aufpl_nch
*                                                 aplzl = lw_afab-aplzl_nch.
*        if sy-subrc eq 0.
*          wa_afab-aufpl_nch = lw_afab-aufpl_vor.
*          wa_afab-aplzl_nch = wa_afvc-vornr.
*        endif.
*        wa_afab-aufnr = lv_order.
*        call function 'CONVERSION_EXIT_AOBAR_OUTPUT'
*          exporting
*            input  = lw_afab-aobar
*          importing
*            output = lw_afab-aobar.
*
*        wa_afab-aobar = lw_afab-aobar.
*        wa_afab-vornc = lw_afab-vornc.
*        append wa_afab to et_afab.
*      endloop.
    endif.


  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_ORDERS
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_orders.
    types : begin of ty_arbpl1,
              arbpl type arbpl,
            end of ty_arbpl1.
    types : begin of ty_stat,
              stat type jest-stat,
            end of ty_stat.

    types : begin of ty_jest ,
              aufpl type afvc-aufpl,
              aplzl type afvc-aplzl,
              objnr type afvc-objnr,
              stat  type jest-stat,
              txt04 type j_txt04,
            end of ty_jest.

    data : lt_arbpl       type table of ty_arbpl1,
           lw_arbpl       type ty_arbpl1,
           lt_oper_arbpl  type table of ty_arbpl,
           lw_oper_arbpl  type ty_arbpl,
           lt_stat        type standard table of ty_stat,
           lt_jest        type sorted table of ty_jest
                              with unique key aufpl aplzl txt04,
           lw_stat        type ty_stat,
           lw_jest        type ty_jest,
           ra_arbpl1      type range of arbpl,
           rw_arbpl       like line of ra_arbpl1,
           ra_oper_arbid  type range of afvc-arbid,
           rw_oper_arbid  like line of ra_oper_arbid,
           ra_stat        type range of jest-stat,
           rw_stat        like line of ra_stat,
           lv_datelow     type char20,
           lv_datehigh    type char20,
           lv_phase(100)  type c,
           lw_line        type bsvx-sttxt,
           lw_uline       type bsvx-sttxt,
           lw_uline1      type bsvx-sttxt,
           ajax_value     type string,
           lv_param_value type xuvalue.

    clear : lw_arbpl,
            rw_arbpl,
            lv_param_value.

    refresh : lt_arbpl,
              ra_arbpl1.

* Get maintenance planning plant parameter for this user.
    select single parva into lv_param_value from usr05
        where bname = sy-uname
          and parid = 'IWK'.

    delete ra_date where option = 'EQ' and low = '00000000'.

    split wa_default-arbpl at ',' into table lt_arbpl.
    loop at lt_arbpl into lw_arbpl.
      rw_arbpl-low = lw_arbpl-arbpl.
      rw_arbpl-sign = 'I'.
      rw_arbpl-option = 'EQ'.
      append rw_arbpl to ra_arbpl1.
    endloop.

*    Get operational work center
    split wa_default-oper_arbpl at ',' into table lt_oper_arbpl.
    loop at lt_oper_arbpl into lw_oper_arbpl.
      select single objid into rw_oper_arbid-low from crhd
            where arbpl = lw_oper_arbpl-arbpl
              and werks = lv_param_value.
      rw_oper_arbid-sign = 'I'.
      rw_oper_arbid-option = 'EQ'.
      append rw_oper_arbid to ra_oper_arbid.
    endloop.

* Get user status for order header.
*    split wa_default-estat at ',' into table lt_stat.
    if not wa_default-status is initial.
      condense wa_default-status.
      split wa_default-status at ' ' into table lt_stat.
      loop at lt_stat into lw_stat.
        rw_stat-low = lw_stat-stat.
        rw_stat-sign = 'I'.
        rw_stat-option = 'EQ'.
        append rw_stat to ra_stat.
      endloop.
    endif.
* start of chanegs by Nivya -- 4/19/18 -- to add created and relased selection in fliter
    if ( wa_default-phase0 = 'X' and wa_default-phase1 = 'X' ) or
       ( wa_default-phase0 is initial and wa_default-phase1 is initial ).
      concatenate 'a~phas0 = ' '`X`'  'or a~phas1 = ' '`X`' into lv_phase separated by space.
    elseif wa_default-phase0 = 'X'.
      concatenate 'a~phas0 = ' '`X`' into lv_phase separated by space.
    elseif wa_default-phase1 = 'X'.
      concatenate 'a~phas1 = ' '`X`' into lv_phase separated by space.
    endif.

* Check for Main work center and work orders selections are selected or not
    if ra_arbpl1 is not initial and wa_default-ordr_sel = 'X' .
*      select aufnr
*             erdat
*             ktext
*             vaplz
*             phas0
*             phas1
*             from aufk into table gt_worklist
*               where ( phas0 = 'X' or phas1 = 'X' )
*                 and vaplz in ra_arbpl1
*                 and erdat in ra_date
*                 and loekz eq space
*                 and werks = lv_param_value.
      select a~aufnr
           a~erdat
           a~ktext
           a~phas0
           a~phas1
           a~vaplz
           a~objnr as objnr1
           b~gstrp
           c~aufpl
           c~aplzl
           c~vornr
           c~ltxa1
           c~arbid
           c~objnr
           from aufk as a inner join afko as b
            on a~aufnr = b~aufnr inner join afvc as c
            on b~aufpl = c~aufpl inner join afih as d
            on a~aufnr = d~aufnr into
            corresponding fields of table gt_worklist
             where c~loekz eq space
               and c~phflg eq space
               and d~ingpr in ra_ingpr
               and (lv_phase)
*               and ( a~phas0 = 'X' or a~phas1 = 'X' )
               and a~vaplz in ra_arbpl1
               and a~erdat in ra_date
               and a~loekz eq space
               and a~werks = lv_param_value.
      if sy-subrc eq 0.
        sort gt_worklist by aufnr vornr.
        delete adjacent duplicates from gt_worklist comparing aufnr.
      endif.
    endif.

    if gt_worklist[] is not initial.
      if ra_stat is not initial." and
*         wa_default-selection ne 'Operations'.
        select afvc~aufpl
               afvc~aplzl
               afvc~objnr
               jest~stat
               tj30t~txt04
            into table lt_jest
            from afvc
            inner join jest
              on afvc~objnr = jest~objnr
            inner join jsto
              on afvc~objnr = jsto~objnr
            inner join tj30t
              on jsto~stsma = tj30t~stsma
             and jest~stat = tj30t~estat
            for all entries in gt_worklist
              where jest~inact eq space
*                and ( tj30t~txt04 in ra_stat or tj30t~txt04 = 'PLNC' )
                and afvc~aufpl = gt_worklist-aufpl
                and afvc~aplzl = gt_worklist-aplzl
                and tj30t~spras = sy-langu.

        loop at gt_worklist into wa_worklist.
*         Exclude PLNC orders unless specifically requested.
          if wa_default-status ns 'PLNC'.
            read table lt_jest
                with key aufpl = wa_worklist-aufpl
                         aplzl = wa_worklist-aplzl
                         txt04 = 'PLNC'
                transporting no fields.

            if sy-subrc = 0.
              delete gt_worklist.
              continue.
            endif.
          endif.

          loop at lt_jest into lw_jest
              where aufpl = wa_worklist-aufpl
                and aplzl = wa_worklist-aplzl
                and txt04 in ra_stat.
            exit.
          endloop.

          if sy-subrc ne 0.
            delete gt_worklist where aufpl = wa_worklist-aufpl
                                 and aplzl = wa_worklist-aplzl.
          endif.
        endloop.
      endif.
    endif.
    loop at gt_worklist into wa_worklist.
      wa_worklist-offline_state = 'None'.
      wa_worklist-icon = 'sap-icon://activity-2'.
      wa_worklist-color = 'Success'.
      if wa_worklist-phas0 = 'X'.
        wa_worklist-status = 'Created'.
      else.
        wa_worklist-status = 'Released'.
      endif.
*   Read header status
      clear : lw_line,
                lw_uline.
      call function 'STATUS_TEXT_EDIT'
        exporting
          flg_user_stat    = 'X'
          objnr            = wa_worklist-objnr1
          spras            = sy-langu
        importing
          line             = lw_line
          user_line        = lw_uline
        exceptions
          object_not_found = 1
          others           = 2.

      if lw_uline is not initial.
        if lw_uline cs 'CKLT'.
          count = count + 1.
        endif.
        if lw_uline cs 'OPRC'.
          count = count + 1.
        endif.
        if lw_uline cs 'DETC'.
          count = count + 1.
        endif.
      endif.
      ajax_value = wa_worklist-aufnr.
*  get operations details
      get_operations(
      exporting
         ajax_value = ajax_value ).
*     importing
*       et_resb = gt_resb
*       et_afvc = gt_afvc
*       et_afab = gt_afab ).
*         Claculate progress tracking
      tot_count = tot_count + 3.
      if count > 0.
        gv_ord_detail-prcnt = ( count / tot_count ) * 100.
      else.
        gv_ord_detail-progress = '0'.
      endif.
      if gv_ord_detail-prcnt = '100'.
        wa_worklist-plan = '100 %'.
      endif.

      modify gt_worklist from wa_worklist.
      clear : gv_ord_detail,
              count,
              tot_count.
    endloop.
* Get operation list
    if ra_oper_arbid is not initial and wa_default-oper_sel = 'X'.
      select a~aufnr
           a~erdat
           a~ktext
           a~vaplz
           a~phas0
           a~phas1
           b~gstrp
           c~aufpl
           c~aplzl
           c~vornr
           c~ltxa1
           c~arbid
           c~objnr
           from aufk as a inner join afko as b
            on a~aufnr = b~aufnr inner join afvc as c
            on b~aufpl = c~aufpl inner join afih as d
            on a~aufnr = d~aufnr into
            corresponding fields of table gt_operlist
             where c~arbid in ra_oper_arbid"ra_arbpl
               and c~loekz eq space
               and c~phflg eq space
               and d~ingpr in ra_ingpr
               and (lv_phase)
*               and ( a~phas0 = 'X' or a~phas1 = 'X' )
*               and a~vaplz in ra_arbpl1
               and a~erdat in ra_date
               and a~loekz eq space
               and a~werks = lv_param_value.
      if sy-subrc eq 0.
        sort gt_operlist by aufnr vornr.
        delete adjacent duplicates from gt_operlist comparing aufnr vornr.
      endif.
      clear : wa_operlist.
      loop at gt_operlist into wa_operlist.
        wa_operlist-offline_state = 'None'.
        wa_operlist-icon = 'sap-icon://activity-2'.
        wa_operlist-color = 'Success'.
        if wa_operlist-phas0 = 'X'.
          wa_operlist-status = 'Created'.
        else.
          wa_operlist-status = 'Released'.
        endif.
        concatenate wa_operlist-aufnr '-' wa_operlist-vornr
                    into wa_operlist-oroper separated by space.
*        get user status of operation
        clear : lw_line,
                lw_uline.
        call function 'STATUS_TEXT_EDIT'
          exporting
            flg_user_stat    = 'X'
            objnr            = wa_operlist-objnr
            spras            = sy-langu
          importing
            line             = lw_line
            user_line        = lw_uline
          exceptions
            object_not_found = 1
            others           = 2.
        if lw_uline cs 'NPLN'.
          wa_operlist-plan = '100%'.
        else.
          if lw_uline cs 'ESTH' and
             lw_uline cs 'DETC' and
             lw_uline cs 'PRTO' and
             lw_uline cs 'JBPK'.
            wa_operlist-plan = '100%'.
          endif.
        endif.

        modify gt_operlist from wa_operlist.
      endloop.
    endif.


  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_ORDER_DETAILS
* +-------------------------------------------------------------------------------------------------+
* | [--->] AJAX_VALUE                     TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_order_details.

    data: wa_detail_ord type ty_ord_detail,
          lv_tplnr      type ilom_strno.
    data : lt_tpir2    type table of tpir2t,
           lw_tpir2    type tpir2t,
           craft_class type ref to ycl_pm_craftperson_class,
           lv_ord_num  type aufnr,
           lv_vornr    type char10,
           lv_matnr    type mara-matnr,
           lt_aufk     type table of rihaufk,
           lt_pmco     type table of pmco_ext,
           lt_comp     type table of pmco_kgr,
           lw_comp     type pmco_kgr,
           lw_line     type bsvx-sttxt,
           lw_uline    type bsvx-sttxt,
           lv_act_cost type pmco_kgr-ikostenkgr,
           lw_aufk     type rihaufk,
           lv_previous type ypm_material_search_result.
    data : lt_tp type table of tpmp.
    data: lw_exp type  ty_ext_profile.
    clear : count.
    split ajax_value at '-' into lv_ord_num lv_vornr.

*Operation Details based on work order number

    select single a~aufnr
                  a~gltrp
                  a~gstrp
                  a~gsuzp
                  a~gluzp
                  b~auart
                  b~erdat
                  b~werks
                  b~user4
                  b~objnr
                  b~vaplz
                  b~waers
                  b~phas0
                  b~phas1
                  b~ktext
                  c~priok
                  c~iloan
                  c~equnr
                  c~ilart
                  c~revnr
                  c~ingpr
                  from afko as a inner join aufk as b
                  on a~aufnr eq b~aufnr inner join afih as c
                  on b~aufnr eq c~aufnr
                  into wa_detail_ord
                  where a~aufnr eq lv_ord_num.
    if sy-subrc eq 0.
*      Planner text
      select single innam from t024i
       into wa_detail_ord-ingpr_text
        where iwerk = wa_detail_ord-werks
         and  ingrp = wa_detail_ord-ingpr.

*    Get the default control key from main work center
      select single steus from crhd into wa_detail_ord-steus
                          where objty = 'A'
                           and arbpl = wa_detail_ord-vaplz
                           and werks = wa_detail_ord-werks.

      clear : lv_ord_num.
      wa_detail_ord-icon = 'sap-icon://activity-2'.
      wa_detail_ord-color = 'Success'.
      if wa_detail_ord-phas0 = 'X'.
        wa_detail_ord-status = 'Created'.
      else.
        wa_detail_ord-status = 'Released'.
      endif.
*      get the header user status
      call function 'STATUS_TEXT_EDIT'
        exporting
          flg_user_stat    = 'X'
          objnr            = wa_detail_ord-objnr
          spras            = sy-langu
        importing
          line             = lw_line
          user_line        = lw_uline
        exceptions
          object_not_found = 1
          others           = 2.
      if sy-subrc <> 0.
* Implement suitable error handling here
      endif.
      if lw_uline is not initial.
        if lw_uline cs 'CKLT'.
          wa_detail_ord-cklt = 'true'.
          count = count + 1.
        endif.
        if lw_uline cs 'OPRC'.
          wa_detail_ord-oprc = 'true'.
          count = count + 1.
        endif.
        if lw_uline cs 'DETC'.
          wa_detail_ord-detc = 'true'.
          count = count + 1.
        endif.
      endif.
*      wa_detail_ord-progress = '40%'.
      select single tplnr
              from iloa
              into wa_detail_ord-tplnr
              where iloan eq wa_detail_ord-iloan.


      call function 'CONVERSION_EXIT_TPLNR_OUTPUT'
        exporting
          input  = wa_detail_ord-tplnr
        importing
          output = wa_detail_ord-tplnr.


*Texts

      select single priokx
         from t356_t
         into wa_detail_ord-pri_text
         where spras eq sy-langu
         and artpr eq 'PB'
        and priok eq wa_detail_ord-priok.

      select single ilatx into wa_detail_ord-act_detail from t353i_t
       where ilart eq wa_detail_ord-ilart
       and spras = sy-langu.


      select single eqktx from eqkt into wa_detail_ord-equi_text
      where equnr eq wa_detail_ord-equnr
      and spras eq sy-langu.

      read table gt_location into wa_location with key tplnr = wa_detail_ord-tplnr.
      read table gt_revision into wa_revision with key revnr = wa_detail_ord-revnr.


      wa_detail_ord-loc_detail = wa_location-pltxt.
      wa_detail_ord-rev_text = wa_revision-revtx.


*Long text
      wa_head-tdname = sy-mandt && ajax_value.
      wa_head-tdid = 'KOPF'.
      wa_head-tdobject = 'AUFK'.
      wa_head-tdspras = sy-langu.

      call method me->read_text
        exporting
          wa_head                = wa_head
          iv_preserve_formatting = abap_true
        importing
          text                   = wa_detail_ord-long_text.


      move-corresponding wa_detail_ord to gv_ord_detail.

*  Get Task List for Function Locations
      if gv_ord_detail-tplnr is not initial.
        call function 'CONVERSION_EXIT_TPLNR_INPUT'
          exporting
            input     = gv_ord_detail-tplnr
          importing
            output    = lv_tplnr
          exceptions
            not_found = 1
            others    = 2.

        select a~plnty
               a~plnnr
               a~plnal
               a~zaehl
               a~datuv
               a~ktext as ltxa1
               into corresponding fields of table gt_tapl
               from plko as a inner join tapl as b
               on a~plnty = b~plnty and a~plnnr = b~plnnr
               and a~zaehl = b~zaehl
                         where b~datuv le gv_ord_detail-gstrp
                          and  b~plnty = 'T'
                          and  b~iwerk = gv_ord_detail-werks
                           and b~tplnr = lv_tplnr.
        if sy-subrc eq 0.
          sort gt_tapl by plnnr plnal.
          delete adjacent duplicates from gt_tapl comparing all fields.
          select a~plnty a~plnnr a~zaehl a~arbid a~datuv a~ltxa1 a~dauno a~arbei a~anzzl
                                 b~plnal from plpo as a
                              inner join plas as b on a~plnnr = b~plnnr
                                              and a~plnkn = b~plnkn into
                         corresponding fields of table gt_tapl_item
                          for all entries in gt_tapl
                          where a~plnty = 'T'
                            and a~plnnr = gt_tapl-plnnr
                            and b~plnal = gt_tapl-plnal.
          if sy-subrc eq 0.
            sort gt_tapl_item by plnnr plnal.
            clear : wa_eapl_item.
            loop at gt_tapl_item into wa_eapl_item.
              select single arbpl into wa_eapl_item-arbpl from crhd
                                      where objid = wa_eapl_item-arbid
                                        and objty = 'A'.
              if sy-subrc eq 0.
                modify gt_tapl_item from wa_eapl_item.
              endif.
            endloop.
            sort gt_tapl_item by plnnr plnal zaehl.
          endif.
        endif.
      endif.
* Get Task List for Equipment
      if gv_ord_detail-equnr is not initial.
        select a~plnty
                 a~plnnr
                 a~plnal
                 a~zaehl
                 a~datuv
                 a~ktext as ltxa1
                   into corresponding fields of table gt_eapl
                 from plko as a inner join eapl as b
                 on a~plnty = b~plnty and a~plnnr = b~plnnr
                           and a~zaehl = b~zaehl
                           where b~datuv le gv_ord_detail-gstrp
                            and b~plnty = 'E'
                            and  b~iwerk = gv_ord_detail-werks
                             and b~equnr = gv_ord_detail-equnr.
        if sy-subrc eq 0.
          sort gt_eapl by plnnr plnal.
          select a~plnty a~plnnr a~zaehl a~datuv a~arbid a~ltxa1 a~dauno a~arbei a~anzzl
                                  b~plnal from plpo as a
                          inner join plas as b on a~plnnr = b~plnnr
                                              and a~plnkn = b~plnkn into
                            corresponding fields of table gt_eapl_item
                                   for all entries in gt_eapl
                                   where a~plnty = 'E'
                                     and a~plnnr = gt_eapl-plnnr
                                     and b~plnal = gt_eapl-plnal.
          if sy-subrc eq 0.
            sort gt_eapl_item by plnnr plnal.
            clear : wa_eapl_item.
            loop at gt_eapl_item into wa_eapl_item.
              select single arbpl into wa_eapl_item-arbpl from crhd
                                      where objid = wa_eapl_item-arbid
                                        and objty = 'A'.
              if sy-subrc eq 0.
                modify gt_eapl_item from wa_eapl_item.
              endif.
            endloop.
            sort gt_eapl_item by plnnr plnal zaehl.
          endif.
        endif.
      endif.

* Get estimated costs
      clear : lw_aufk.
      refresh : lt_aufk,
                lt_comp,
                lt_pmco.
      move-corresponding wa_detail_ord to lw_aufk.
      append lw_aufk to lt_aufk.
      call function 'PM_WORKORDER_COSTS_LIST'
        exporting
          list_currency  = wa_detail_ord-waers
          pmco_detail    = 'X'
          all_currencies = 'X'
*         EXTERNAL_CALL  = ' '
        tables
          list_aufk      = lt_aufk
          list_pmco      = lt_pmco
          comp_pmco      = lt_comp
        exceptions
          no_orders      = 1
          no_currency    = 2
          no_costs_found = 3
          others         = 4.
      if sy-subrc <> 0.
* Implement suitable error handling here
      endif.
*IKOSTENKGR
      select * from tpir2t into table lt_tpir2 where langu = sy-langu
                                                  and appl = 'PM'
                                                  and kokrs = '1000'
                                                  and acpos ne 'PM07TRANS'.
      clear : lv_act_cost.
      loop at lt_tpir2 into lw_tpir2.
        clear : wa_pmco,
                lw_comp.
        read table lt_comp into lw_comp with key acpos = lw_tpir2-acpos.
        if sy-subrc eq 0.
          move-corresponding lw_comp to wa_pmco.
          lv_act_cost = lv_act_cost + lw_comp-ikostenkgr.
        else.
          wa_pmco-acpos = lw_tpir2-acpos.
          wa_pmco-aufnr = wa_detail_ord-aufnr.
        endif.
        wa_pmco-waers = 'USD'.
        wa_pmco-ktext = lw_tpir2-ktext.
        append wa_pmco to gt_pmco.
      endloop.
      gv_ord_detail-ikostenkgr = lv_act_cost.
*   Get operations for the order
      get_operations(
       exporting
          ajax_value = ajax_value
      importing
        et_resb = gt_resb
        et_afvc = gt_afvc
        et_afab = gt_afab
        et_all_afvc = gt_all_afvc ).

      condense lv_vornr.
      read table gt_afvc into wa_afvc with key vornr = lv_vornr.
* Get default profles for external profile.

      select * from tpmp into table lt_tp where werks = gv_ord_detail-werks
                                                and auart = gv_ord_detail-auart.
      if sy-subrc eq 0.
*        get defult profile for external services
        select kstar ekorg ekgrp matkl from tpext into table gt_exp
                for all entries in lt_tp where profil = lt_tp-profext.
        if sy-subrc eq 0.
          loop at gt_exp into lw_exp.
            lw_exp-auart = gv_ord_detail-auart.
            modify gt_exp from lw_exp.
          endloop.
        endif.
*          get defult profile for external materials
        select kstar ekorg ekgrp matkl from tpext into table gt_exp_mat
              for all entries in lt_tp where profil = lt_tp-profmat.
        if sy-subrc eq 0.
          loop at gt_exp_mat into lw_exp.
            lw_exp-auart = gv_ord_detail-auart.
            modify gt_exp_mat from lw_exp.
          endloop.
        endif.
      endif.
*   Claculate progress tracking
      tot_count = tot_count + 3.
      if count > 0.
        gv_ord_detail-prcnt = ( count / tot_count ) * 100.
      else.
        gv_ord_detail-progress = '0'.
      endif.
      gv_ord_detail-progress = gv_ord_detail-prcnt.
      concatenate gv_ord_detail-progress '%' into gv_ord_detail-progress.

      get_attachments_list( ajax_value ).


*      Get Material BOM search Tree
      lv_ord_num = ajax_value.
      create object craft_class.

      call method craft_class->get_fl_struct
        exporting
          iv_work_order = lv_ord_num
        importing
          et_fl_struct  = gt_fl_struct.

*Material parts history search

      call method craft_class->get_previous_issue
        exporting
          iv_work_order     = lv_ord_num
        receiving
          rt_previous_issue = gt_previous_issue.

      loop at gt_previous_issue into lv_previous.
        clear : lv_matnr.
        call function 'CONVERSION_EXIT_MATN1_INPUT'
          exporting
            input        = lv_previous-material
          importing
            output       = lv_matnr
          exceptions
            length_error = 1
            others       = 2.
        if sy-subrc <> 0.
* Implement suitable error handling here
        endif.

        select single bklas from mbew into lv_previous-bklas
                                          where matnr = lv_matnr.
        if sy-subrc eq 0.
*          exclude valutation class which has non stock materials
          if lv_previous-bklas = '0018'.
            delete gt_previous_issue where material = lv_previous-material.
          endif.
        endif.
      endloop.
*  Equipment history.
      get_equipment_history(
  exporting
    iv_work_order = gv_ord_detail-aufnr
  importing
    et_equi       = gt_equi
    et_tech_hist  = gt_tech_hist
    et_act_hist   = gt_act_hist
    et_resb_hist  = gt_resb_hist
).
      call function 'CONVERSION_EXIT_ALPHA_OUTPUT'
        exporting
          input  = gv_ord_detail-equnr
        importing
          output = gv_ord_detail-equnr.

      get_attachments_data( ).
    endif.

  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->GET_WORKCENTERS
* +-------------------------------------------------------------------------------------------------+
* | [--->] AJAX_VALUE                     TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_workcenters.
    data: lv_param_value type xuvalue,
          lv_plant       type werks_d,
          lw_work        type ty_work.
    data: lv_search_string(100) type c,
          lv_string             type string.

    refresh gt_workcenter.

* Get maintenance planning plant parameter for this user.
    select single parva into lv_param_value from usr05
        where bname = sy-uname
          and parid = 'IWK'.
*    wa_default-arbpl = 'MMECH'.
*    wa_default-wrk_center = '10003849'.
    if sy-subrc = 0 and not lv_param_value is initial.
      lv_plant = lv_param_value.
*   Get Default work center
      clear : lv_param_value.
      select single parva into lv_param_value from usr05
                                where bname = sy-uname
                                  and parid = 'AGR'.
      if sy-subrc eq 0 and not lv_param_value is initial.
        wa_default-arbpl = lv_param_value.
        select single objid from crhd into wa_default-wrk_center
                                where arbpl = wa_default-arbpl
                                  and werks = lv_plant.
        if sy-subrc ne 0.
          clear : wa_default-arbpl,
                  wa_default-wrk_center.
        endif.
      endif.

      check not ajax_value is initial.
      check strlen( ajax_value ) >= 3.
      lv_string = ajax_value.
      replace '*' in lv_string with ''.
      replace '%' in lv_string with ''.
      lv_search_string = `%` && lv_string && `%`.
      translate lv_search_string to upper case.

      select crhd~arbpl
             crhd~objty
             crhd~objid
             crhd~werks
             crtx~ktext into table gt_workcenter
          from crtx
          inner join crhd on crtx~objty = crhd~objty
                         and crtx~objid = crhd~objid
          where crtx~spras = sy-langu
            and crhd~werks = lv_plant
            and ( crtx~ktext_up like lv_search_string
               or crhd~arbpl like lv_search_string )
          order by crhd~arbpl.

      if sy-subrc eq 0.
        loop at gt_workcenter into lw_work.
          concatenate lw_work-cr_objid
                      lw_work-cr_ktext into lw_work-text separated by space.
          modify gt_workcenter from lw_work transporting text.
        endloop.
      endif.
    endif.
* Get user status for work order
    select * from tj30t into table gt_tj30t
                          where stsma = 'PMOPER'
                            and spras = sy-langu.

    append initial line to gt_tj30t.
    sort gt_tj30t by estat.
*    append initial line to  gt_workcenter.
    sort gt_workcenter by arbpl.
*      select crhd~arbpl
*             crhd~objty
*             crhd~objid
*             crhd~werks
*             crtx~ktext
*          into table gt_workcenter
*          from crhd
*          inner join crtx on crhd~objty = crtx~objty
*                         and crhd~objid = crtx~objid
*            where crhd~werks = lv_plant
*            and crtx~spras = 'E'.



  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Private Method YCL_PM_PLANNER_CLASS->GET_WORKCENTER_ID
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_workcenter_id.
    types : begin of ty_stsma,
              auart type AUFART,
              stsma type j_stsma,
            end of ty_stsma.
    data: lv_param_value type xuvalue,
          lv_plant       type werks_d,
          lw_work        type ty_work,
          lt_stsma       type table of ty_stsma,"j_stsma,
          lv_stsma       type ty_stsma,
          r_stsma        type range of j_stsma,
          lr_stsma       like line of r_stsma.

* Get maintenance planning plant parameter for this user.
    select single parva into lv_param_value from usr05
        where bname = sy-uname
          and parid = 'IWK'.


    lv_plant = lv_param_value.
    clear lv_param_value.
    select single parva into lv_param_value from usr05
                          where bname = sy-uname
                            and parid = 'AGR'.

    if sy-subrc eq 0 and not lv_param_value is initial.
      wa_default-arbpl = lv_param_value.
      select single objid from crhd into  wa_default-wrk_center
                              where arbpl = wa_default-arbpl
                                and werks = lv_plant.
      if sy-subrc ne 0.
        clear : wa_default-arbpl,
                wa_default-wrk_center.
      endif.
    endif.

* Get user status for work order

    select * from tj30t into table gt_tj30t
                          where stsma = 'PMOPER'
                            and spras = sy-langu.

    sort gt_tj30t.
    delete adjacent duplicates from gt_tj30t comparing all FIELDS.
    sort gt_tj30t by txt30.

* Get Notification status for Notifications
 select tj30~estat tj30t~txt04 tj30t~txt30 into table gt_status
        from tj30
        inner join tj30t on tj30~stsma = tj30t~stsma
                        and tj30~estat = tj30t~estat
        where tj30~stsma in ( 'PMNOTM1', 'PMNOTMC', 'PMNOTRC' )
          and tj30~stonr = 0
          and tj30t~spras = sy-langu.
*   get plant section
   select * from t357 into TABLE gt_plantsection
                 where werks = lv_plant ORDER BY fing.

* Get F4 helps for planner group
    select * from t024a into table gt_t024a
                      where werks = lv_plant.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Private Method YCL_PM_PLANNER_CLASS->GET_WORKCENTER_OPER
* +-------------------------------------------------------------------------------------------------+
* | [--->] AJAX_VALUE                     TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method get_workcenter_oper.
    data: lv_param_value type xuvalue,
          lv_plant       type werks_d,
          lw_work        type ty_work.
    data: lv_search_string(100) type c,
          lv_string             type string.

    refresh gt_workcenter_oper.
* Get maintenance planning plant parameter for this user.
    select single parva into lv_param_value from usr05
        where bname = sy-uname
          and parid = 'IWK'.
    if sy-subrc eq 0 and lv_param_value is not initial.
      lv_plant = lv_param_value.
      check not ajax_value is initial.
      check strlen( ajax_value ) >= 3.
      lv_string = ajax_value.
      replace '*' in lv_string with ''.
      replace '%' in lv_string with ''.
      lv_search_string = `%` && lv_string && `%`.
      translate lv_search_string to upper case.

      select crhd~arbpl
             crhd~objty
             crhd~objid
             crhd~werks
             crtx~ktext into table gt_workcenter_oper
          from crtx
          inner join crhd on crtx~objty = crhd~objty
                         and crtx~objid = crhd~objid
          where crtx~spras = sy-langu
            and crhd~werks = lv_plant
            and ( crtx~ktext_up like lv_search_string
               or crhd~arbpl like lv_search_string )
          order by crhd~arbpl.

      if sy-subrc eq 0.
        loop at gt_workcenter_oper into lw_work.
          concatenate lw_work-cr_objid
                      lw_work-cr_ktext into lw_work-text separated by space.
          modify gt_workcenter_oper from lw_work transporting text.
        endloop.
      endif.
    endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->OPERATION_SAVE
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method operation_save.
      types: begin of ty_user,
             user type bapi_alm_order_usrstat-user_st_text,
           end of ty_user.
 data :    lv_ref          type i,
           lv_textref      type i,
           header          type standard table of bapi_alm_order_headers_i,
           wa_header       type                   bapi_alm_order_headers_i,
           header_up       type standard table of bapi_alm_order_headers_up,
           wa_header_up    type                   bapi_alm_order_headers_up,
           component       type table of          bapi_alm_order_component,
           component_up    type table of          bapi_alm_order_component_up,
           wa_component    type                   bapi_alm_order_component,
           wa_component_up type                   bapi_alm_order_component_up,
           wa_methods      type                   bapi_alm_order_method,
           methods         type standard table of bapi_alm_order_method,
           operation       type table of          bapi_alm_order_operation,
           ls_operation    like line of           operation,
           operation_up    type table of          bapi_alm_order_operation_up,
           ls_operation_x  like line of           operation_up,
           lt_relations    type table of bapi_alm_order_relation,
           ls_relation     type bapi_alm_order_relation,
           lt_relations_up type table of bapi_alm_order_relation_up,
           ls_relations_up type bapi_alm_order_relation_up,
           userstatus      type table of bapi_alm_order_usrstat,
           userstat        type bapi_alm_order_usrstat,
           costs           type standard table of bapi_alm_order_costs_est_i,
           lt_costs        type bapi_alm_order_costs_est_i,
           text            type table of          bapi_alm_text,
           wa_text         type                   bapi_alm_text,
           text_lines      type table of          bapi_alm_text_lines,
           wa_textlines    type                   bapi_alm_text_lines,
           lt_time         type table of bapi_alm_timeconfirmation,
           ls_time         type bapi_alm_timeconfirmation,
           return          type standard table of bapiret2,
           ls_return       type                   bapiret2,
           lv_msg          type bapi_msg,
           lt_return       type table of bapi_alm_return,
           lw_return       type bapi_alm_return,
           text_lines_tab  type standard table of tline,
           lv_res          type char1,
           lt_user         type table of ty_user,
           lw_user         type ty_user,
           ln1 type i.
data : lt_text  type standard table of string,
           lw_text  type                   string,
           lv_arbpl type crhd-arbpl,
           lv_lstar type crco-lstar,
           lt_tline type standard table of tline,
           wa_tline type                   tline,
           wa_head  type                   thead.
    data : it_soli type table of soli,
           wa_soli type soli.
    data: resb_text(1000) type c.
    data lv_nl_index type i.
    data maktx(40).
    data : lt_info       type table of uinfo2,
           wa_info       type uinfo2,
           lt_return_msg type bapiret2_t.
    data : ln type i.
    data: lt_uuids        type hashed table of ypmnptuuid with unique key table_line,
          ls_ypmnptrecpr  type ypmnptrecpr,
          ls_ypmnptjobpkg type ypmnptjobpkg,
          lv_1week_ago    type dats,
          ls_attachment   type ty_attachment,
          ls_lporb        type sibflporb,
          lv_file_data    type xstring,
          lt_gos_messages type bapirettab,
          ls_gos_message  type bapiret2,
          lv_tcode        type sytcode.


*    Pass operation data
    clear : lv_ref.
    loop at gt_afvc into wa_afvc where chng ne space
                                  and chng ne 'D'.

      lv_ref = lv_ref + 1.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_afvc-vornr
        importing
          output = wa_afvc-vornr.

      if wa_afvc-chng = 'C'.
        wa_methods-refnumber  = lv_ref.
        wa_methods-method     = 'CHANGE'.
        wa_methods-objecttype = 'OPERATION'.
        concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
        append wa_methods to  methods.
      elseif wa_afvc-chng = 'N'.
        wa_methods-refnumber  = lv_ref.
        wa_methods-method     = 'CREATE'.
        wa_methods-objecttype = 'OPERATION'.
        concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
        append wa_methods to  methods.
*        elseif wa_afvc-chng = 'D'.
*          wa_methods-refnumber  = lv_ref.
*          wa_methods-method     = 'DELETE'.
*          wa_methods-objecttype = 'OPERATION'.
*          concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
*          append wa_methods to  methods.
      endif.
*        if wa_afvc-chng ne 'D'.
      ls_operation-activity = wa_afvc-vornr.
      ls_operation-plant           = gv_ord_detail-werks.
      ls_operation-control_key     = wa_afvc-steus.
      ls_operation-work_activity   = wa_afvc-arbei.
      ls_operation-duration_normal = wa_afvc-dauno.
      ls_operation-duration_normal_unit = 'H'.
      ls_operation-un_work      = 'H'.
      ls_operation-number_of_capacities  = wa_afvc-anzzl.
      ls_operation-calc_key        = '2'.
      ls_operation-work_cntr = wa_afvc-arbpl.
      ls_operation-description     = wa_afvc-ltxa1.
      ls_operation-funct_loc       = wa_afvc-tplnr.
      ls_operation-usr00 = wa_afvc-usr00. "Note1
      ls_operation-usr01 = wa_afvc-usr01. "Note2
      ls_operation-usr02 = wa_afvc-usr02. "Note3
      ls_operation-usr09 = wa_afvc-usr09. "Preliminary planned date
      if wa_afvc-steus = 'PM02'.
        call function 'CONVERSION_EXIT_ALPHA_INPUT'
          exporting
            input  = wa_afvc-lifnr
          importing
            output = wa_afvc-lifnr.

        ls_operation-matl_group = wa_afvc-matkl.
        ls_operation-purch_org = wa_afvc-ekorg.
        ls_operation-pur_group = wa_afvc-ekgrp.
        ls_operation-preq_name = wa_afvc-afnam.
        ls_operation-gr_rcpt = wa_afvc-wempf.
        ls_operation-vendor_no = wa_afvc-lifnr.
        ls_operation-unload_pt = wa_afvc-ablad.
        ls_operation-trackingno = wa_afvc-bednr.
      endif.
      append ls_operation to operation.

      ls_operation_x-description = 'X'.
      ls_operation_x-plant           = 'X'.
      ls_operation_x-control_key     = 'X'.
      ls_operation_x-duration_normal = 'X'.
      ls_operation_x-number_of_capacities = 'X'.
      ls_operation_x-work_activity   = 'X'.
      ls_operation_x-calc_key        = 'X'.
      ls_operation_x-work_cntr       = 'X'.
      ls_operation_x-activity        = 'X'.
      ls_operation_x-duration_normal_unit = 'X'.
      ls_operation_x-un_work         = 'X'.
      ls_operation_x-description     = 'X'.
      ls_operation_x-funct_loc       = 'X'.
      ls_operation_x-usr00 = 'X'.
      ls_operation_x-usr01 = 'X'.
      ls_operation_x-usr02 = 'X'.
      ls_operation_x-usr09 = 'X'.
      if wa_afvc-steus = 'PM02'.
        ls_operation_x-matl_group = 'X'.
        ls_operation_x-purch_org = 'X'.
        ls_operation_x-pur_group = 'X'.
        ls_operation_x-preq_name = 'X'.
        ls_operation_x-gr_rcpt = 'X'.
        ls_operation_x-vendor_no = 'X'.
        ls_operation_x-unload_pt = 'X'.
        ls_operation_x-trackingno = 'X'.
      endif.
      append ls_operation_x to  operation_up.

*         Operation Long Text
      if wa_afvc-text is initial.
        wa_afvc-text = wa_afvc-ltxa1.
      endif.

      refresh text_lines_tab.
      text_lines_tab = prepare_long_text( wa_afvc-text ).

      clear wa_text.
      describe table text_lines lines ln1.
      wa_text-textstart = ln1 + 1.

      append lines of text_lines_tab to text_lines.
      describe table text_lines lines ln1.
      wa_text-orderid = wa_afvc-aufnr.
      wa_text-activity = wa_afvc-vornr.
      wa_text-textend = ln1.
      append wa_text to text.

      clear wa_methods.
      lv_textref = lv_textref + 1.
      wa_methods-refnumber = lv_textref.
      wa_methods-method = 'CHANGE'.
      wa_methods-objecttype = 'TEXT'.
      concatenate wa_afvc-aufnr wa_afvc-vornr into wa_methods-objectkey in character mode.
      append wa_methods to methods.

*      Update User Status
      if wa_afvc-usrst ne space.
        split wa_afvc-usrst at space into table lt_user.
        loop at lt_user into lw_user.
          userstat-user_st_text = lw_user-user.
          userstat-langu = sy-langu.
          userstat-inactive = ' '.
          append userstat to userstatus.
        endloop.
        wa_methods-refnumber = lv_ref.
        wa_methods-objecttype = 'USERSTATUS'.
        wa_methods-method = 'CHANGE'.
        wa_methods-objectkey = wa_afvc-aufnr && wa_afvc-vornr.
        append wa_methods to methods.
      endif.
*        endif.
    endloop.

* Delete Operations
*      clear : lv_ref.
    loop at gt_afvc into wa_afvc where chng = 'D'.
      lv_ref = lv_ref + 1.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_afvc-vornr
        importing
          output = wa_afvc-vornr.
      wa_methods-refnumber  = lv_ref.
      wa_methods-method     = 'DELETE'.
      wa_methods-objecttype = 'OPERATION'.
      concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
      append wa_methods to  methods.
    endloop.

*    Pass parts table
    clear : lv_ref,
            maktx.
    loop at gt_resb1 into wa_resb where chng ne space.
      lv_ref = lv_ref + 1.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_resb-vornr
        importing
          output = wa_resb-vornr.
      if wa_resb-chng = 'C'.
        wa_methods-refnumber    = lv_ref.
        wa_methods-objecttype   = 'COMPONENT'.
        wa_methods-method       = 'CHANGE'.
        concatenate  wa_resb-aufnr wa_resb-vornr wa_resb-posnr into wa_methods-objectkey respecting blanks.
        append wa_methods to methods.
      elseif wa_resb-chng = 'N'.
        wa_methods-refnumber    = lv_ref.
        wa_methods-objecttype   = 'COMPONENT'.
        wa_methods-method       = 'CREATE'.
        concatenate  wa_resb-aufnr wa_resb-vornr wa_resb-posnr into wa_methods-objectkey respecting blanks.
        append wa_methods to methods.
      endif.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_resb-matnr
        importing
          output = wa_resb-matnr.
      wa_component-material = wa_resb-matnr.
      wa_component-activity     = wa_resb-vornr.
      wa_component-item_number  = wa_resb-posnr.
      if wa_resb-rsnum is not initial.
        wa_component-reserv_no               =  wa_resb-rsnum.
      else.
        lv_res = 'X'.
      endif.
      wa_component-res_item                =  wa_resb-rspos.
      wa_component-requirement_quantity    =  wa_resb-bdmng.
      wa_component-requirement_quantity_unit =  wa_resb-meins.
      wa_component-plant                     =  wa_resb-werks."lgort.
*      wa_component-stge_loc                  = wa_resb-lgort.
      wa_component-item_cat                  =  wa_resb-postp.
      wa_component-item_text1 = wa_resb-potx1.

      if wa_component-item_cat = 'L'.
        wa_component-matl_desc = wa_resb-potx1.
      elseif wa_component-item_cat = 'N'.
        wa_component-pur_group = wa_resb-ekgrp.
        wa_component-matl_group = wa_resb-matkl.
        wa_component-vendor_no = wa_resb-lifnr.
        wa_component-purch_org  = wa_resb-ekorg.
      endif.
      append wa_component to component.

      wa_component_up-material                  =  'X'.
      wa_component_up-requirement_quantity      =  'X'.
      wa_component_up-requirement_quantity_unit =  'X'.
      wa_component_up-plant                     =  'X'.
*      wa_component_up-stge_loc                  =  'X'.
      wa_component_up-item_text1 = 'X'.
      wa_component_up-matl_desc = 'X'.
      if wa_component-item_cat = 'N'.
        wa_component_up-pur_group = 'X'.
        wa_component_up-matl_group = 'X'.
        wa_component_up-vendor_no = 'X'.
        wa_component_up-purch_org  = 'X'.
      endif.
      append wa_component_up to component_up.
*      Long text saving
      clear : lw_text,
            ln1,
            wa_textlines.
      refresh : lt_text.

      resb_text = wa_resb-text.
      call function 'RKD_WORD_WRAP'
        exporting
          textline            = resb_text
          outputlen           = 70
        tables
          out_lines           = lt_text
        exceptions
          outputlen_too_large = 1
          others              = 2.

      read table lt_text into lw_text index 1.
      describe table text_lines lines ln1.

      if not lw_text is initial and not wa_resb-rsnum is initial.
        wa_text-textstart = ln1 + 1.

        maktx = wa_resb-potx1.
        wa_textlines-tdformat = '*'.
        concatenate maktx ''  into wa_textlines-tdline respecting blanks.
        append wa_textlines to text_lines.


        loop at lt_text into lw_text .
          if wa_resb-chng ne 'N' and sy-tabix = 1.
            concatenate maktx ''  into wa_textlines-tdline respecting blanks.
            wa_textlines-tdformat = '*'.
            append wa_textlines to text_lines.
          endif.

          wa_textlines-tdformat = '*'.
          wa_textlines-tdline = lw_text.
          append wa_textlines to text_lines.
        endloop.

        clear : ln1.
        describe table text_lines lines ln1.
        wa_text-orderid = wa_resb-aufnr.
        wa_text-activity = wa_resb-posnr.
        wa_text-reserv_no = wa_resb-rsnum.
        wa_text-res_item = wa_resb-rspos.
        wa_text-textend = ln1.
        append wa_text to text.

        lv_textref = lv_textref + 1.
        wa_methods-refnumber = lv_textref.
        wa_methods-method = 'CHANGE'.
        wa_methods-objecttype = 'TEXT'.
        concatenate wa_resb-aufnr wa_resb-rspos into wa_methods-objectkey in character mode.
        append wa_methods to methods.
      endif.
    endloop.

    lv_ref = 0.
    loop at gt_afab into wa_afab where chng ne space.
*       Check whether entry was already processed.
      read table lt_uuids with key table_line = wa_afab-uuid
          transporting no fields.
      if sy-subrc = 0.
        delete gt_afab.
        continue.
      endif.

      clear ls_relation.
      ls_relation-order_predecessor     = wa_afab-aufnr.
      ls_relation-operation_predecessor = wa_afab-aplzl_vor.
      ls_relation-order_successor       = wa_afab-aufnr.
      ls_relation-operation_successor   = wa_afab-aplzl_nch.
*        ls_relation-relation_type         = 'FS'.
      call function 'CONVERSION_EXIT_AOBAR_INPUT'
        exporting
          input  = wa_afab-aobar
        importing
          output = ls_relation-relation_type.

      append ls_relation to lt_relations.

      clear ls_relations_up.
      ls_relations_up-order_predecessor     = 'X'.
      ls_relations_up-operation_predecessor = 'X'.
      ls_relations_up-order_successor       = 'X'.
      ls_relations_up-operation_successor   = 'X'.
      ls_relations_up-relation_type         = 'X'.
      append ls_relations_up to lt_relations_up.

      clear wa_methods.
      wa_methods-objecttype = 'RELATION'.
      if wa_afab-chng = 'N'. "create new relation
        wa_methods-method = 'CREATE'.
      elseif wa_afab-chng = 'U'. "change existing relation
        wa_methods-method = 'CHANGE'.
      elseif wa_afab-chng = 'D'. "Delete existing relation
        wa_methods-method = 'DELETE'.
      endif.
      wa_methods-objectkey  =
          wa_afab-aufnr && wa_afab-aplzl_vor && wa_afab-aufnr && wa_afab-aplzl_nch.
      lv_ref = lv_ref + 1.
      wa_methods-refnumber  = lv_ref.
      append wa_methods to methods.
    endloop.

* Save the data
      clear wa_methods.
      wa_methods-refnumber  = '000001'.
      wa_methods-method     = 'SAVE'.
      wa_methods-objectkey  = gv_ord_detail-aufnr.
      append wa_methods to methods.

    call function 'BAPI_ALM_ORDER_MAINTAIN'
      tables
        it_methods      = methods
        it_userstatus   = userstatus
        it_operation    = operation
        it_operation_up = operation_up
        it_relation     = lt_relations
        it_relation_up  = lt_relations_up
        it_component    = component
        it_component_up = component_up
        it_text         = text
        it_text_lines   = text_lines
*       IT_TASKLISTS    =
        return          = return.

       read table return into ls_return with key type = 'E'.
      if sy-subrc ne 0.
        clear ls_ypmnptrecpr.
        ls_ypmnptrecpr-object_type   = 'PLANNERS'.
        ls_ypmnptrecpr-object_number = wa_afvc-aufnr.
        ls_ypmnptrecpr-guid          = wa_afvc-uuid.
        ls_ypmnptrecpr-record_date   = sy-datum.
        ls_ypmnptrecpr-record_table  = 'OROPER'.
        insert ypmnptrecpr from ls_ypmnptrecpr.
           call function 'BAPI_TRANSACTION_COMMIT'
          exporting
            wait = 'X'.

       endif.


  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Protected Method YCL_PM_PLANNER_CLASS->PREPARE_LONG_TEXT
* +-------------------------------------------------------------------------------------------------+
* | [--->] IV_LONG_TEXT                   TYPE        STRING
* | [<-()] RT_TEXT_LINES                  TYPE        RSFBTLTAB
* +--------------------------------------------------------------------------------------</SIGNATURE>
method PREPARE_LONG_TEXT.
  data: lt_stream    type table of w3_html,
        lv_stream    type w3_html,
        lv_long_text type string,
        lv_len       type i.

  refresh rt_text_lines.

  lv_long_text = iv_long_text.

  while strlen( lv_long_text ) > 255.
    lv_stream = lv_long_text(255).
    append lv_stream to lt_stream.
    shift lv_long_text by 255 places.
  endwhile.
  lv_stream = lv_long_text.
  append lv_stream to lt_stream.

  call function 'CONVERT_STREAM_TO_ITF_TEXT'
    tables
      text_stream = lt_stream
      itf_text    = rt_text_lines.
endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->READ_TEXT
* +-------------------------------------------------------------------------------------------------+
* | [--->] WA_HEAD                        TYPE        THEAD
* | [--->] IV_PRESERVE_FORMATTING         TYPE        FLAG (default =ABAP_TRUE)
* | [<---] TEXT                           TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method read_text.
    data: read_text(1000)  type c, lv_firstline(70).
    data : string1(70), string2(70).
    data : lt_text type standard table of string,
           lw_text type                   string.

    data: lt_stream type table of w3_html,
          lv_stream type w3_html.

    clear : read_text,
            text.
    call function 'READ_TEXT'
      exporting
        client                  = sy-mandt
        id                      = wa_head-tdid
        language                = wa_head-tdspras
        name                    = wa_head-tdname
        object                  = wa_head-tdobject
      tables
        lines                   = gt_lines
      exceptions
        id                      = 1
        language                = 2
        name                    = 3
        not_found               = 4
        object                  = 5
        reference_check         = 6
        wrong_access_to_archive = 7
        others                  = 8.

    if iv_preserve_formatting = abap_true.
      if sy-subrc = 0 and not gt_lines[] is initial.
        read table gt_lines into wa_lines with key tdformat = '*'.
        if sy-subrc ne 0.
          loop at gt_lines into wa_lines.
            wa_lines-tdformat = '*'.
            shift wa_lines-tdline left deleting leading '*'.
            modify gt_lines from wa_lines.
          endloop.
        endif.
        call function 'CONVERT_ITF_TO_STREAM_TEXT'
          tables
            itf_text    = gt_lines
            text_stream = lt_stream.

        loop at lt_stream into lv_stream.
          text = text && lv_stream.
        endloop.
      endif.
    else.
      if sy-subrc eq 0.
        loop at gt_lines into wa_lines.
          clear: string1, string2.
          shift wa_lines-tdline left deleting leading '*'.
          shift wa_lines-tdline left deleting leading space.
          if sy-tabix = 1.
            lv_firstline = wa_lines-tdline.
          else.
            if sy-tabix = 2.
              split wa_lines-tdline  at cl_abap_char_utilities=>newline into string1 string2.
              concatenate string1 string2 into read_text separated by space.

            else.
              split wa_lines-tdline  at cl_abap_char_utilities=>newline into string1 string2.
              concatenate read_text string1 string2  into read_text separated by space.
            endif.
          endif.
        endloop.
* Wrap the text
        refresh: lt_text[] .
        call function 'RKD_WORD_WRAP'
          exporting
            textline            = read_text
            outputlen           = 70
          tables
            out_lines           = lt_text
          exceptions
            outputlen_too_large = 1
            others              = 2.

        if sy-subrc eq 0.
          clear : text,
                  read_text.

          if lt_text[] is initial.
            text = lv_firstline.
            return.
          endif.

          loop at lt_text into lw_text.
            if sy-tabix = 1.
              concatenate
                 lv_firstline
                 cl_abap_char_utilities=>cr_lf
                 into text.
            endif.

            replace all occurrences of regex cl_abap_char_utilities=>cr_lf
                                            in lw_text with ' '.

            concatenate text
                 lw_text
                 cl_abap_char_utilities=>cr_lf
                 into text.
          endloop.
        endif.

      endif.
    endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Public Method YCL_PM_PLANNER_CLASS->SAVE_ORDER
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
  method save_order.
    types: begin of ty_user,
             user type bapi_alm_order_usrstat-user_st_text,
           end of ty_user.
    data : lv_ref               type i,
           lv_textref           type i,
           lv_useref            type i,
           lv_ref_limit         type i,
           header               type standard table of bapi_alm_order_headers_i,
           wa_header            type                   bapi_alm_order_headers_i,
           header_up            type standard table of bapi_alm_order_headers_up,
           wa_header_up         type                   bapi_alm_order_headers_up,
           component            type table of          bapi_alm_order_component,
           component_up         type table of          bapi_alm_order_component_up,
           wa_component         type                   bapi_alm_order_component,
           wa_component_up      type                   bapi_alm_order_component_up,
           wa_methods           type                   bapi_alm_order_method,
           methods              type standard table of bapi_alm_order_method,
           operation            type table of          bapi_alm_order_operation,
           ls_operation         like line of           operation,
           operation_up         type table of          bapi_alm_order_operation_up,
           ls_operation_x       like line of           operation_up,
           lt_relations         type table of bapi_alm_order_relation,
           ls_relation          type bapi_alm_order_relation,
           lt_relations_up      type table of bapi_alm_order_relation_up,
           ls_relations_up      type bapi_alm_order_relation_up,
           userstatus           type table of bapi_alm_order_usrstat,
           userstat             type bapi_alm_order_usrstat,
           costs                type standard table of bapi_alm_order_costs_est_i,
           lt_costs             type bapi_alm_order_costs_est_i,
           text                 type table of          bapi_alm_text,
           wa_text              type                   bapi_alm_text,
           text_lines           type table of          bapi_alm_text_lines,
           wa_textlines         type                   bapi_alm_text_lines,
           lt_tasklist          type table of bapi_alm_order_tasklists_i,
           lw_tasklist          type bapi_alm_order_tasklists_i,
           lt_time              type table of bapi_alm_timeconfirmation,
           ls_time              type bapi_alm_timeconfirmation,
           return               type standard table of bapiret2,
           return1              type standard table of bapiret2,
           ls_return            type                   bapiret2,
           lv_msg               type bapi_msg,
           lt_return            type table of bapi_alm_return,
           lw_return            type bapi_alm_return,
           lt_service	          type table of bapi_alm_srv_limit_data,
           ls_service           type  bapi_alm_srv_limit_data,
           lt_service_up        type table of  bapi_alm_srv_limit_data_up,
           ls_service_up        type  bapi_alm_srv_limit_data_up,
           lt_servicelines      type table of bapi_alm_srv_service_line,
           lt_servicelines_up   type table of bapi_alm_srv_service_line_up,
           ls_servicelines      type table of  bapi_alm_srv_service_line,
           ls_servicelines_up   type  bapi_alm_srv_service_line_up,
           lt_serviceoutline    type table of  bapi_alm_srv_outline,
           lt_serviceoutline_up type table of	bapi_alm_srv_outline_up,
           text_lines_tab       type standard table of tline,
           text_line            type tline,
           lv_length            type i,
           lv_res               type char1,
           lt_user              type table of ty_user,
           lw_user              type ty_user,
           str_ln               type i,
           stxt                 type jsto-stsma,
           usr_stxt             type bsvx-sttxt.

    data : lt_text  type standard table of string,
           lw_text  type                   string,
           ln1      type i,
           lv_arbpl type crhd-arbpl,
           lv_lstar type crco-lstar,
           lv_rsnum type resb-rsnum,
           lt_tline type standard table of tline,
           wa_tline type                   tline,
           wa_head  type                   thead.
    data : it_soli type table of soli,
           wa_soli type soli.
    data: resb_text(1000) type c.
    data lv_nl_index type i.
    data maktx(40).
    data : lt_info       type table of uinfo2,
           wa_info       type uinfo2,
           lt_return_msg type bapiret2_t.
    data : ln      type i,
           ln_oper type i.
    data: lt_uuids         type hashed table of ypmnptuuid with unique key table_line,
          ls_ypmnptrecpr   type ypmnptrecpr,
          ls_ypmnptjobpkg  type ypmnptjobpkg,
          lv_1week_ago     type dats,
          ls_attachment    type ty_attachment,
          ls_lporb         type sibflporb,
          lv_file_data     type xstring,
          lt_gos_messages  type bapirettab,
          ls_gos_message   type bapiret2,
          lv_tcode         type sytcode,
          ls_attach_jobpkg type ty_jobpkg.


    lv_1week_ago = sy-datum - 7.
    select guid into table lt_uuids from ypmnptrecpr
        where object_type   = 'PLANNERS'
          and object_number = gv_ord_detail-aufnr
          and record_date  >= lv_1week_ago.

    read table lt_uuids with key table_line = gv_ord_detail-uuid
                        transporting no fields.
*    if sy-subrc ne 0.
    wa_methods-refnumber    = '000001'.
    wa_methods-objecttype   = 'HEADER'.
    wa_methods-method       = 'CHANGE'.
    wa_methods-objectkey    = gv_ord_detail-aufnr.
    append wa_methods to methods.
*    Pass header data info
    wa_header-orderid = gv_ord_detail-aufnr.
    wa_header-start_date  = gv_ord_detail-gstrp. "basic start date
    wa_header-finish_date = gv_ord_detail-gltrp. "end date
    wa_header-revision = gv_ord_detail-revnr. "revision
    wa_header-priority = gv_ord_detail-priok. "priority
    wa_header-pmacttype = gv_ord_detail-ilart. "actvity type
    wa_header-plangroup = gv_ord_detail-ingpr. "planner group
    call function 'CONVERSION_EXIT_TPLNR_INPUT'
      exporting
        input     = gv_ord_detail-tplnr
      importing
        output    = gv_ord_detail-tplnr
      exceptions
        not_found = 1
        others    = 2.
    if sy-subrc <> 0.
* Implement suitable error handling here
    endif.
    call function 'CONVERSION_EXIT_ALPHA_INPUT'
      exporting
        input  = gv_ord_detail-equnr
      importing
        output = gv_ord_detail-equnr.


    wa_header-funct_loc = gv_ord_detail-tplnr. "fun location
    wa_header-equipment = gv_ord_detail-equnr.
*      wa_header-estimated_costs = gv_ord_detail-user4.
    wa_header-plant = gv_ord_detail-werks.
    append wa_header to header.

    wa_header_up-orderid = gv_ord_detail-aufnr.
    wa_header_up-plant = 'X'.
    wa_header_up-start_date  = 'X'. "basic start date
    wa_header_up-finish_date = 'X'. "end date
    wa_header_up-revision = 'X'. "revision
    wa_header_up-priority = 'X'. "priority
    wa_header_up-pmacttype = 'X'. "actvity type
    wa_header_up-funct_loc = 'X'. "fun location
    wa_header_up-equipment = 'X'.
    wa_header_up-plangroup = 'X'.
*      wa_header_up-estimated_costs = 'X'.
    append wa_header_up to header_up.

*  change header status
*    if gv_ord_detail-cklt = 'X' or
*       gv_ord_detail-oprc = 'X' or
*       gv_ord_detail-detc = 'X'.
*  Get current user status.
    clear : stxt,
            usr_stxt.
    call function 'STATUS_TEXT_EDIT'
      exporting
        objnr            = gv_ord_detail-objnr
        spras            = sy-langu
        flg_user_stat    = 'X'
      importing
        e_stsma          = stxt
        user_line        = usr_stxt
      exceptions
        object_not_found = 1
        others           = 2.
    lv_useref = '000001'.
    if gv_ord_detail-cklt = 'X'.
      wa_methods-refnumber = lv_useref.
      wa_methods-objecttype = 'USERSTATUS'.
      wa_methods-method = 'CHANGE'.
      wa_methods-objectkey = gv_ord_detail-aufnr.
      append wa_methods to methods.

      userstat-user_st_text = 'CKLT'.
      userstat-langu = sy-langu.
      userstat-inactive = ' '.
      append userstat to userstatus.
      lv_useref = lv_useref + 1.
    else.
      if usr_stxt cs 'CKLT'.
        wa_methods-refnumber = lv_useref.
        wa_methods-objecttype = 'USERSTATUS'.
        wa_methods-method = 'CHANGE'.
        wa_methods-objectkey = gv_ord_detail-aufnr.
        append wa_methods to methods.

        userstat-user_st_text = 'CKLT'.
        userstat-langu = sy-langu.
        userstat-inactive = 'X'.
        append userstat to userstatus.
        lv_useref = lv_useref + 1.
      endif.
    endif.

    if gv_ord_detail-oprc = 'X'.
      wa_methods-refnumber = lv_useref.
      wa_methods-objecttype = 'USERSTATUS'.
      wa_methods-method = 'CHANGE'.
      wa_methods-objectkey = gv_ord_detail-aufnr.
      append wa_methods to methods.

      userstat-user_st_text = 'OPRC'.
      userstat-langu = sy-langu.
      userstat-inactive = ' '.
      append userstat to userstatus.
      lv_useref = lv_useref + 1.
    else.
      if usr_stxt cs 'OPRC'.
        wa_methods-refnumber = lv_useref.
        wa_methods-objecttype = 'USERSTATUS'.
        wa_methods-method = 'CHANGE'.
        wa_methods-objectkey = gv_ord_detail-aufnr.
        append wa_methods to methods.

        userstat-user_st_text = 'OPRC'.
        userstat-langu = sy-langu.
        userstat-inactive = 'X'.
        append userstat to userstatus.
        lv_useref = lv_useref + 1.
      endif.
    endif.

    if gv_ord_detail-detc = 'X'.
      wa_methods-refnumber = lv_useref.
      wa_methods-objecttype = 'USERSTATUS'.
      wa_methods-method = 'CHANGE'.
      wa_methods-objectkey = gv_ord_detail-aufnr.
      append wa_methods to methods.

      userstat-user_st_text = 'DETC'.
      userstat-langu = sy-langu.
      userstat-inactive = ' '.
      append userstat to userstatus.

      lv_useref = lv_useref + 1.
    else.
      if usr_stxt cs 'DETC'.
        wa_methods-refnumber = lv_useref.
        wa_methods-objecttype = 'USERSTATUS'.
        wa_methods-method = 'CHANGE'.
        wa_methods-objectkey = gv_ord_detail-aufnr.
        append wa_methods to methods.

        userstat-user_st_text = 'DETC'.
        userstat-langu = sy-langu.
        userstat-inactive = 'X'.
        append userstat to userstatus.

        lv_useref = lv_useref + 1.
      endif.
    endif.
*    endif.

*  2/13/18 --> Adding Release order functionality
    if gv_ord_detail-rel = 'X'.
      clear wa_methods.
      wa_methods-refnumber  = '000001'.
      wa_methods-objecttype = 'HEADER'.
      wa_methods-method     = 'RELEASE'.
      wa_methods-objectkey  = gv_ord_detail-aufnr.
      append wa_methods to methods.

      export lv_no_popup = 'X' to memory id 'NEPTUNE_NO_AVAILABILITY_CHECK'.
    endif.
*    Pass operation data
    clear : lv_ref.
    sort gt_afvc by aufnr vornr.
    loop at gt_afvc into wa_afvc where chng eq 'N'
                                    or chng eq 'C'.
      read table lt_uuids with key table_line = wa_afvc-uuid
                   transporting no fields.
      if sy-subrc eq 0 and wa_afvc-chng = 'N'.
        delete gt_afvc .
        continue.
      endif.
      lv_ref = lv_ref + 1.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_afvc-vornr
        importing
          output = wa_afvc-vornr.

      if wa_afvc-chng = 'C'.
        wa_methods-refnumber  = lv_ref.
        wa_methods-method     = 'CHANGE'.
        wa_methods-objecttype = 'OPERATION'.
        concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
        append wa_methods to  methods.
      elseif wa_afvc-chng = 'N'.
        wa_methods-refnumber  = lv_ref.
        wa_methods-method     = 'CREATE'.
        wa_methods-objecttype = 'OPERATION'.
        concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
        append wa_methods to  methods.
*        elseif wa_afvc-chng = 'D'.
*          wa_methods-refnumber  = lv_ref.
*          wa_methods-method     = 'DELETE'.
*          wa_methods-objecttype = 'OPERATION'.
*          concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
*          append wa_methods to  methods.
      endif.
*        if wa_afvc-chng ne 'D'.
      ls_operation-activity = wa_afvc-vornr.
      ls_operation-plant           = gv_ord_detail-werks.
      ls_operation-control_key     = wa_afvc-steus.
      ls_operation-work_activity   = wa_afvc-arbei.
      ls_operation-duration_normal = wa_afvc-dauno.
      ls_operation-duration_normal_unit = 'H'.
      ls_operation-un_work      = 'H'.
      ls_operation-number_of_capacities  = wa_afvc-anzzl.
      ls_operation-calc_key        = '2'.
      ls_operation-work_cntr = wa_afvc-arbpl.
      ls_operation-description     = wa_afvc-ltxa1.
      ls_operation-funct_loc       = wa_afvc-tplnr.
      ls_operation-usr00 = wa_afvc-usr00. "Note1
      ls_operation-usr01 = wa_afvc-usr01. "Note2
      ls_operation-usr02 = wa_afvc-usr02. "Note3
      ls_operation-usr09 = wa_afvc-usr09. "Preliminary planned date
       call function 'CONVERT_DATE_TO_INTERNAL'
        exporting
          date_external                  = wa_afvc-usr09
       IMPORTING
         DATE_INTERNAL                  = ls_operation-usr09
       EXCEPTIONS
         DATE_EXTERNAL_IS_INVALID       = 1
         OTHERS                         = 2.

      if wa_afvc-steus = 'PM02'.
        call function 'CONVERSION_EXIT_ALPHA_INPUT'
          exporting
            input  = wa_afvc-lifnr
          importing
            output = wa_afvc-lifnr.
*        call function 'CONVERSION_EXIT_ALPHA_INPUT'
*          exporting
*            input  = wa_afvc-matkl
*          importing
*            output = wa_afvc-matkl.

        ls_operation-matl_group = wa_afvc-matkl.
        ls_operation-purch_org = wa_afvc-ekorg.
        ls_operation-pur_group = wa_afvc-ekgrp.
        ls_operation-preq_name = wa_afvc-afnam.
        ls_operation-gr_rcpt = wa_afvc-wempf.
        ls_operation-vendor_no = wa_afvc-lifnr.
        ls_operation-unload_pt = wa_afvc-ablad.
        ls_operation-trackingno = wa_afvc-bednr.
        ls_operation-cost_element = wa_afvc-sakto.
        if wa_afvc-commitment is not initial.
*          add service limits
          clear ls_service.
          ls_service-activity      = wa_afvc-vornr.
          ls_service-overall_limit = wa_afvc-commitment.
          ls_service-exp_value     = wa_afvc-commitment.
          ls_service-cost_element = wa_afvc-sakto.
          append ls_service to lt_service.

          export lv_allow_cost_element = 'X' to memory id 'NEPTUNE_ALLOW_COST_ELEMENT'.

          clear wa_methods.
          wa_methods-refnumber  = lv_ref_limit + 1.
          wa_methods-method     = 'CREATE'.
          wa_methods-objecttype = 'SERVICELIMIT'.
          wa_methods-objectkey  = wa_afvc-aufnr && wa_afvc-vornr.
          append wa_methods to methods.
        endif.
      endif.
      if wa_afvc-ktsch is not initial.
        ls_operation-standard_text_key = wa_afvc-ktsch.
        ls_operation_x-standard_text_key = 'X'.
      endif.
      append ls_operation to operation.

      ls_operation_x-description = 'X'.
      ls_operation_x-plant           = 'X'.
      ls_operation_x-control_key     = 'X'.
      ls_operation_x-duration_normal = 'X'.
      ls_operation_x-number_of_capacities = 'X'.
      ls_operation_x-work_activity   = 'X'.
      ls_operation_x-calc_key        = 'X'.
      ls_operation_x-work_cntr       = 'X'.
      ls_operation_x-activity        = 'X'.
      ls_operation_x-duration_normal_unit = 'X'.
      ls_operation_x-un_work         = 'X'.
      ls_operation_x-description     = 'X'.
      ls_operation_x-funct_loc       = 'X'.
      ls_operation_x-usr00 = 'X'.
      ls_operation_x-usr01 = 'X'.
      ls_operation_x-usr02 = 'X'.
      ls_operation_x-usr09 = 'X'.

      if wa_afvc-steus = 'PM02'.
        ls_operation_x-matl_group = 'X'.
        ls_operation_x-purch_org = 'X'.
        ls_operation_x-pur_group = 'X'.
        ls_operation_x-preq_name = 'X'.
        ls_operation_x-gr_rcpt = 'X'.
        ls_operation_x-vendor_no = 'X'.
        ls_operation_x-unload_pt = 'X'.
        ls_operation_x-trackingno = 'X'.
        ls_operation_x-cost_element = 'X'.
      endif.
      append ls_operation_x to  operation_up.

*      str_len = st
*         Operation Long Text
      if wa_afvc-text is initial or strlen( wa_afvc-text ) le 40.
        wa_afvc-text = wa_afvc-ltxa1.
      endif.


      refresh text_lines_tab.
      text_lines_tab = prepare_long_text( wa_afvc-text ).

      clear wa_text.
      describe table text_lines lines ln1.
      wa_text-textstart = ln1 + 1.

      append lines of text_lines_tab to text_lines.
      describe table text_lines lines ln1.
      wa_text-orderid = wa_afvc-aufnr.
      wa_text-activity = wa_afvc-vornr.
      wa_text-textend = ln1.
      append wa_text to text.

      clear wa_methods.
      lv_textref = lv_textref + 1.
      wa_methods-refnumber = lv_textref.
      wa_methods-method = 'CHANGE'.
      wa_methods-objecttype = 'TEXT'.
      concatenate wa_afvc-aufnr wa_afvc-vornr into wa_methods-objectkey in character mode.
      append wa_methods to methods.

*      Update User Status
      if wa_afvc-esth = 'X'.
        concatenate wa_afvc-usrst 'ESTH' into wa_afvc-usrst separated by space.
      endif.

      if wa_afvc-detc = 'X'.
        concatenate wa_afvc-usrst 'DETC' into wa_afvc-usrst separated by space.
      endif.
      if wa_afvc-prto = 'X'.
        concatenate wa_afvc-usrst 'PRTO' into wa_afvc-usrst separated by space.
      endif.
      if wa_afvc-jbpk = 'X'.
        concatenate wa_afvc-usrst 'JBPK' into wa_afvc-usrst separated by space.
      endif.
      if wa_afvc-npln = 'X'.
        concatenate wa_afvc-usrst 'NPLN' into wa_afvc-usrst separated by space.
      endif.

      if wa_afvc-usrst ne space.
        split wa_afvc-usrst at space into table lt_user.
        sort lt_user.
        delete lt_user where user = space.
        delete adjacent duplicates from lt_user comparing all fields.
        if lv_useref is initial.
          lv_useref = '000001'.
        endif.
*        check if status is already active in the system
        if wa_afvc-objnr ne space.
          clear : stxt,
            usr_stxt.
          call function 'STATUS_TEXT_EDIT'
            exporting
              objnr            = wa_afvc-objnr
              spras            = sy-langu
              flg_user_stat    = 'X'
            importing
              e_stsma          = stxt
              user_line        = usr_stxt
            exceptions
              object_not_found = 1
              others           = 2.
        endif.
        loop at lt_user into lw_user.
          if usr_stxt cs lw_user-user.
            if ( lw_user-user = 'ESTH' and wa_afvc-esth = 'X' ) or
               ( lw_user-user = 'DETC' and wa_afvc-detc = 'X' ) or
               ( lw_user-user = 'PRTO' and wa_afvc-prto = 'X' ) or
               ( lw_user-user = 'JBPK' and wa_afvc-jbpk = 'X' ) or
               ( lw_user-user = 'NPLN' and wa_afvc-npln = 'X' ).
              continue.
            endif.
          endif.
          userstat-user_st_text = lw_user-user.
          userstat-langu = sy-langu.
          userstat-inactive = ' '.
          if ( lw_user-user = 'ESTH' and wa_afvc-esth is initial ).
            userstat-inactive = 'X'.
          endif.
          if ( lw_user-user = 'DETC' and wa_afvc-detc is initial ).
            userstat-inactive = 'X'.
          endif.
          if ( lw_user-user = 'PRTO' and wa_afvc-prto is initial ).
            userstat-inactive = 'X'.
          endif.
          if ( lw_user-user = 'JBPK' and wa_afvc-jbpk is initial ).
            userstat-inactive = 'X'.
          endif.
          if ( lw_user-user = 'NPLN' and wa_afvc-npln is initial ).
            userstat-inactive = 'X'.
          endif.
          append userstat to userstatus.
          wa_methods-refnumber = lv_useref.
          wa_methods-objecttype = 'USERSTATUS'.
          wa_methods-method = 'CHANGE'.
          wa_methods-objectkey = wa_afvc-aufnr && wa_afvc-vornr.
          append wa_methods to methods.
          lv_useref = lv_useref + 1.
        endloop.

      endif.
      clear : ls_operation,
              ls_operation_x,
              wa_afvc.
    endloop.

* Delete Operations
*      clear : lv_ref.
*      clear : ln_oper.
*      describe table gt_afvc lines ln_oper.
*      if ln_oper > 1.
    loop at gt_afvc_del into wa_afvc where chng = 'D'.
      lv_ref = lv_ref + 1.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_afvc-vornr
        importing
          output = wa_afvc-vornr.
      wa_methods-refnumber  = lv_ref.
      wa_methods-method     = 'DELETE'.
      wa_methods-objecttype = 'OPERATION'.
      concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
      append wa_methods to  methods.
    endloop.
**      endif.
*    Pass parts table
    clear : lv_ref,
            maktx,
            wa_methods.
    loop at gt_resb1 into wa_resb where chng ne space.
      read table lt_uuids with key table_line = wa_resb-uuid
                   transporting no fields.
      if sy-subrc eq 0 and wa_resb-chng = 'N'.
        delete gt_resb1 .
        continue.
      endif.

      lv_ref = lv_ref + 1.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_resb-vornr
        importing
          output = wa_resb-vornr.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_resb-posnr
        importing
          output = wa_resb-posnr.

      if wa_resb-chng = 'C'.
        wa_methods-refnumber    = lv_ref.
        wa_methods-objecttype   = 'COMPONENT'.
        wa_methods-method       = 'CHANGE'.
        concatenate  wa_resb-aufnr wa_resb-vornr wa_resb-posnr into wa_methods-objectkey respecting blanks.
        append wa_methods to methods.
      elseif wa_resb-chng = 'N'.
        wa_methods-refnumber    = lv_ref.
        wa_methods-objecttype   = 'COMPONENT'.
        wa_methods-method       = 'CREATE'.
        concatenate  wa_resb-aufnr wa_resb-vornr wa_resb-posnr into wa_methods-objectkey respecting blanks.
        append wa_methods to methods.
      endif.
      call function 'CONVERSION_EXIT_ALPHA_INPUT'
        exporting
          input  = wa_resb-matnr
        importing
          output = wa_resb-matnr.
      wa_component-material = wa_resb-matnr.
      wa_component-activity     = wa_resb-vornr.
      wa_component-item_number  = wa_resb-posnr.
      if wa_resb-rsnum is not initial.
        wa_component-reserv_no               =  wa_resb-rsnum.
      else.
*        if the new component is changed in the app
        select single rsnum from resb into lv_rsnum
                             where aufnr = wa_resb-aufnr.
        if sy-subrc eq 0.
          wa_resb-rsnum = lv_rsnum.
          wa_component-reserv_no = lv_rsnum.
*        else.
*          lv_res = 'X'.
        endif.
      endif.
      wa_component-res_item                =  wa_resb-rspos.
      wa_component-requirement_quantity    =  wa_resb-bdmng.
      wa_component-requirement_quantity_unit =  wa_resb-meins.
      wa_component-plant                     =  wa_resb-werks."lgort.
*      wa_component-stge_loc                  = wa_resb-lgort.
      wa_component-item_cat                  =  wa_resb-postp.
      wa_component-item_text1 = wa_resb-potx1.

      if wa_component-item_cat = 'L'.
        wa_component-matl_desc = wa_resb-potx1.
      elseif wa_component-item_cat = 'N'.
        call function 'CONVERSION_EXIT_ALPHA_INPUT'
          exporting
            input  = wa_resb-lifnr
          importing
            output = wa_resb-lifnr.

*         call function 'CONVERSION_EXIT_ALPHA_INPUT'
*          exporting
*            input         = wa_resb-matkl
*         IMPORTING
*           OUTPUT        = wa_resb-matkl.

        wa_component-pur_group = wa_resb-ekgrp.
        wa_component-matl_group = wa_resb-matkl.
        wa_component-vendor_no = wa_resb-lifnr.
        wa_component-purch_org  = wa_resb-ekorg.
        wa_component-preq_name = wa_resb-afnam.
        wa_component-req_date = wa_resb-bdter.
        call function 'CONVERT_DATE_TO_INTERNAL'
          exporting
            date_external                  = wa_resb-bdter
         IMPORTING
           DATE_INTERNAL                  = wa_component-req_date
         EXCEPTIONS
           DATE_EXTERNAL_IS_INVALID       = 1
           OTHERS                         = 2
                  .
        if sy-subrc <> 0.
* Implement suitable error handling here
        endif.

        wa_component-gr_rcpt  = wa_resb-wempf.
        wa_component-unload_pt  = wa_resb-ablad.
        wa_component-req_time = sy-uzeit.
        wa_component-price = wa_resb-gpreis.
        wa_component-manual_requirements_date = 'X'.
      endif.
      append wa_component to component.

      wa_component_up-material                  =  'X'.
      wa_component_up-requirement_quantity      =  'X'.
      wa_component_up-requirement_quantity_unit =  'X'.
      wa_component_up-plant                     =  'X'.
*      wa_component_up-stge_loc                  =  'X'.
      wa_component_up-item_text1 = 'X'.
      wa_component_up-matl_desc = 'X'.
      if wa_component-item_cat = 'N'.
        wa_component_up-pur_group = 'X'.
        wa_component_up-matl_group = 'X'.
        wa_component_up-vendor_no = 'X'.
        wa_component_up-purch_org  = 'X'.
        wa_component_up-preq_name = 'X'.
        wa_component_up-req_date = 'X'.
        wa_component_up-gr_rcpt	= 'X'.
        wa_component_up-unload_pt	= 'X'.
        wa_component_up-req_time ='X'.
        wa_component_up-manual_requirements_date = 'X'.
        wa_component_up-price = 'X'.
        clear :wa_component_up-material,
        wa_component_up-matl_desc.
      endif.
      append wa_component_up to component_up.
*      Long text saving
      if wa_resb-text is not initial and wa_resb-rsnum is not initial.
        refresh text_lines_tab.
        text_lines_tab = prepare_long_text( wa_resb-text ).

        clear wa_text.
        describe table text_lines lines ln1.
        wa_text-textstart = ln1 + 1.

        append lines of text_lines_tab to text_lines.
        describe table text_lines lines ln1.

        wa_text-orderid = wa_resb-aufnr.
        wa_text-activity = wa_resb-posnr.
        wa_text-reserv_no = wa_resb-rsnum.
        wa_text-res_item = wa_resb-rspos.
        wa_text-textend = ln1.
        append wa_text to text.

        lv_textref = lv_textref + 1.
        wa_methods-refnumber = lv_textref.
        wa_methods-method = 'CHANGE'.
        wa_methods-objecttype = 'TEXT'.
        concatenate wa_resb-aufnr wa_resb-rspos into wa_methods-objectkey in character mode.
        append wa_methods to methods.
      else.
        if wa_resb-text is not initial and wa_resb-rsnum is initial.
          lv_res = 'X'.
        endif.
      endif.
      clear : wa_component,
              wa_component_up,
              wa_resb.
    endloop.
*    Pass estimated costs
    clear : lv_ref.
    clear : wa_methods.
    loop at gt_pmco into wa_pmco where chng ne space
                                  and aufnr eq gv_ord_detail-aufnr.
      lt_costs-value_category = wa_pmco-acpos.
      lt_costs-costs_est = wa_pmco-skostenkgr.
      lt_costs-currency = wa_pmco-waers.
      lv_ref = lv_ref + 1.
      wa_methods-refnumber = lv_ref .
      wa_methods-method = 'CHANGE'.
      wa_methods-objecttype = 'ESTIMATEDCOST'.
      wa_methods-objectkey = gv_ord_detail-aufnr.
      append wa_methods to methods.
      append lt_costs to costs.
    endloop.

    lv_ref = 0.
    loop at gt_afab into wa_afab where chng ne space.
*       Check whether entry was already processed.
      read table lt_uuids with key table_line = wa_afab-uuid
          transporting no fields.
      if sy-subrc = 0.
        delete gt_afab.
        continue.
      endif.
      clear ls_relation.
      ls_relation-order_predecessor     = wa_afab-aufnr.
      ls_relation-operation_predecessor = wa_afab-aplzl_vor.
      ls_relation-order_successor       = wa_afab-aufnr.

      if wa_afab-aobar is not initial.
        call function 'CONVERSION_EXIT_AOBAR_INPUT'
          exporting
            input  = wa_afab-aobar
          importing
            output = ls_relation-relation_type.
      endif.
      if wa_afab-chng = 'D'.
        select single afab~aobar afvc~vornr from afab inner join afvc on
                        afab~aufpl_vor = afvc~aufpl
                    and afab~aplzl_nch = afvc~aplzl into
                ( ls_relation-relation_type, wa_afab-aplzl_nch )
                  where aufpl_vor = wa_afab-aufpl_vor
                    and aplzl_vor = wa_afab-aplzl_vornr.
      endif.
      if wa_afab-chng ne 'U'.
        ls_relation-operation_successor   = wa_afab-aplzl_nch.
        append ls_relation to lt_relations.

        clear wa_methods.
        wa_methods-objecttype = 'RELATION'.
        if wa_afab-chng = 'N'. "create new relation
          wa_methods-method = 'CREATE'.
        elseif wa_afab-chng = 'D'. "Delete existing relation
          wa_methods-method = 'DELETE'.
        endif.
        wa_methods-objectkey  =
            wa_afab-aufnr && wa_afab-aplzl_vor && wa_afab-aufnr && wa_afab-aplzl_nch.
        lv_ref = lv_ref + 1.
        wa_methods-refnumber  = lv_ref.
        append wa_methods to methods.
      else.
        if wa_afab-aplzl_nch ne wa_afab-successor.
          clear : wa_methods.
          wa_methods-objecttype = 'RELATION'.
          wa_methods-method = 'DELETE'.
          wa_methods-objectkey  =
              wa_afab-aufnr && wa_afab-aplzl_vor && wa_afab-aufnr && wa_afab-successor.
          lv_ref = lv_ref + 1.
          wa_methods-refnumber  = lv_ref.
          append wa_methods to methods.

          ls_relation-operation_successor   = wa_afab-successor.
          append ls_relation to lt_relations.

          clear : wa_methods.
          wa_methods-objecttype = 'RELATION'.
          wa_methods-method = 'CREATE'.
          wa_methods-objectkey  =
              wa_afab-aufnr && wa_afab-aplzl_vor && wa_afab-aufnr && wa_afab-aplzl_nch.
          lv_ref = lv_ref + 1.
          wa_methods-refnumber  = lv_ref.
          append wa_methods to methods.

          ls_relation-operation_successor   = wa_afab-aplzl_nch.
          append ls_relation to lt_relations.
        endif.
      endif.

*        clear ls_relations_up.
*        ls_relations_up-order_predecessor     = 'X'.
*        ls_relations_up-operation_predecessor = 'X'.
*        ls_relations_up-order_successor       = 'X'.
*        ls_relations_up-operation_successor   = 'X'.
*        ls_relations_up-relation_type         = 'X'.
*        append ls_relations_up to lt_relations_up.
    endloop.

*     D.Rempe - 11/29/2017 - Maintain header long text
    text_lines_tab = prepare_long_text( gv_ord_detail-long_text ).

    if not gv_ord_detail-ktext is initial.
      lv_length = strlen( gv_ord_detail-ktext ).
      if strlen( gv_ord_detail-long_text ) < lv_length
          or gv_ord_detail-long_text(lv_length) <> gv_ord_detail-ktext.

        text_line-tdline = gv_ord_detail-ktext.
        insert text_line into text_lines_tab index 1.
      endif.
    endif.

    clear wa_text.
    describe table text_lines lines ln1.
    wa_text-orderid   = gv_ord_detail-aufnr.
    wa_text-textstart = ln1 + 1.

    append lines of text_lines_tab to text_lines.
    describe table text_lines lines ln1.
    wa_text-textend = ln1.
    append wa_text to text.

    lv_textref = lv_textref + 1.
    wa_methods-refnumber  = lv_textref.
    wa_methods-method     = 'CHANGE'.
    wa_methods-objecttype = 'TEXT'.
    wa_methods-objectkey  = gv_ord_detail-aufnr.
    append wa_methods to methods.

*  Add tasklist
    if not gt_tasklist[] is initial.
*    tasklists
      clear : lv_ref.
*      lv_ref_task = '
      loop at gt_tasklist into wa_tasklist where aufnr = gv_ord_detail-aufnr.
        lv_ref = lv_ref + 1.
*        wa_tasklist-group_counter = '1'.
        call function 'CONVERSION_EXIT_ALPHA_INPUT'
          exporting
            input  = wa_tasklist-group_counter
          importing
            output = wa_tasklist-group_counter.
        translate wa_tasklist-group_counter to upper case.

*        wa_tasklist-task_list_group = '4390'.
        call function 'CONVERSION_EXIT_ALPHA_INPUT'
          exporting
            input  = wa_tasklist-task_list_group
          importing
            output = wa_tasklist-task_list_group.
        translate wa_tasklist-task_list_group to upper case.

*        wa_tasklist-task_list_type = 'A'.
        call function 'CONVERSION_EXIT_ALPHA_INPUT'
          exporting
            input  = wa_tasklist-task_list_type
          importing
            output = wa_tasklist-task_list_type.
        translate wa_tasklist-task_list_type to upper case.

        append wa_tasklist to lt_tasklist.
        clear wa_methods.
        wa_methods-refnumber  = lv_ref.
        wa_methods-method     = 'ADD'.
        wa_methods-objecttype = 'TASKLIST'.
        wa_methods-objectkey  = gv_ord_detail-aufnr.
        append wa_methods to methods.
      endloop.

    endif.
* Save the data
    clear wa_methods.
    wa_methods-refnumber  = '000000'.
    wa_methods-method     = 'SAVE'.
    wa_methods-objectkey  = gv_ord_detail-aufnr.
    append wa_methods to methods.


    call function 'BAPI_ALM_ORDER_MAINTAIN'
      tables
        it_methods         = methods
        it_header          = header
        it_header_up       = header_up
        it_userstatus      = userstatus
        it_operation       = operation
        it_operation_up    = operation_up
        it_relation        = lt_relations
*       it_relation_up     = lt_relations_up
        it_component       = component
        it_component_up    = component_up
        it_text            = text
        it_text_lines      = text_lines
        it_tasklists       = lt_tasklist
        return             = return
        it_servicelimit    = lt_service
        it_servicelimit_up = lt_service_up
        it_estimated_costs = costs.
    read table return into ls_return with key type = 'E'.
    if sy-subrc ne 0.
      clear ls_ypmnptrecpr.
*        ls_ypmnptrecpr-object_type   = 'PLANNERS'.
*        ls_ypmnptrecpr-object_number = gv_ord_detail-aufnr.
*        ls_ypmnptrecpr-guid          = gv_ord_detail-uuid.
*        ls_ypmnptrecpr-record_date   = sy-datum.
*        ls_ypmnptrecpr-record_table  = 'ORDER'.
*        insert ypmnptrecpr from ls_ypmnptrecpr.
*        inster new components
      loop at gt_resb1 into wa_resb where chng = 'N'.
        clear ls_ypmnptrecpr.
        ls_ypmnptrecpr-object_type   = 'PLANNERS'.
        ls_ypmnptrecpr-object_number = wa_resb-aufnr.
        ls_ypmnptrecpr-guid          = wa_resb-uuid.
        ls_ypmnptrecpr-record_date   = sy-datum.
        ls_ypmnptrecpr-record_table  = 'Component'.
        insert ypmnptrecpr from ls_ypmnptrecpr.
      endloop.
*        insert new operations
      loop at gt_afvc into wa_afvc where chng = 'N'.
        clear ls_ypmnptrecpr.
        ls_ypmnptrecpr-object_type   = 'PLANNERS'.
        ls_ypmnptrecpr-object_number = wa_afvc-aufnr.
        ls_ypmnptrecpr-guid          = wa_afvc-uuid.
        ls_ypmnptrecpr-record_date   = sy-datum.
        ls_ypmnptrecpr-record_table  = 'Operation'.
        insert ypmnptrecpr from ls_ypmnptrecpr.
      endloop.
      call function 'BAPI_TRANSACTION_COMMIT'
        exporting
          wait = 'X'.
* Add component long text for new components
      clear : wa_afvc.
      read table gt_afvc into wa_afvc with key chng = 'TC'.
      if lv_res = 'X' or wa_afvc is not initial.
        refresh : methods,
                  return,
                  text,
                  text_lines,
                  operation,
                  operation_up.
        clear: wa_methods,
               lv_textref.
        wa_methods-refnumber  = '000001'.
        wa_methods-method     = 'SAVE'.
        wa_methods-objectkey  = gv_ord_detail-aufnr.
        append wa_methods to methods.

        clear : lv_ref.
        loop at gt_afvc into wa_afvc where chng = 'TC'.
          read table lt_uuids with key table_line = wa_afvc-uuid
                   transporting no fields.
          if sy-subrc eq 0 and wa_afvc-chng = 'N'.
            delete gt_afvc .
            continue.
          endif.
          lv_ref = lv_ref + 1.
          call function 'CONVERSION_EXIT_ALPHA_INPUT'
            exporting
              input  = wa_afvc-vornr
            importing
              output = wa_afvc-vornr.

*          if wa_afvc-chng = 'C'.
          wa_methods-refnumber  = lv_ref.
          wa_methods-method     = 'CHANGE'.
          wa_methods-objecttype = 'OPERATION'.
          concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
          append wa_methods to  methods.
*          elseif wa_afvc-chng = 'N'.
*            wa_methods-refnumber  = lv_ref.
*            wa_methods-method     = 'CREATE'.
*            wa_methods-objecttype = 'OPERATION'.
*            concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
*            append wa_methods to  methods.
*        elseif wa_afvc-chng = 'D'.
*          wa_methods-refnumber  = lv_ref.
*          wa_methods-method     = 'DELETE'.
*          wa_methods-objecttype = 'OPERATION'.
*          concatenate wa_afvc-aufnr wa_afvc-vornr  into wa_methods-objectkey respecting blanks.
*          append wa_methods to  methods.
*          endif.
*        if wa_afvc-chng ne 'D'.
          ls_operation-activity = wa_afvc-vornr.
          ls_operation-plant           = gv_ord_detail-werks.
          ls_operation-control_key     = wa_afvc-steus.
          ls_operation-work_activity   = wa_afvc-arbei.
          ls_operation-duration_normal = wa_afvc-dauno.
          ls_operation-duration_normal_unit = 'H'.
          ls_operation-un_work      = 'H'.
          ls_operation-number_of_capacities  = wa_afvc-anzzl.
          ls_operation-calc_key        = '2'.
          ls_operation-work_cntr = wa_afvc-arbpl.
          ls_operation-description     = wa_afvc-ltxa1.
          ls_operation-funct_loc       = wa_afvc-tplnr.
          ls_operation-usr00 = wa_afvc-usr00. "Note1
          ls_operation-usr01 = wa_afvc-usr01. "Note2
          ls_operation-usr02 = wa_afvc-usr02. "Note3
          ls_operation-usr09 = wa_afvc-usr09. "Preliminary planned date

          if wa_afvc-steus = 'PM02'.
            call function 'CONVERSION_EXIT_ALPHA_INPUT'
              exporting
                input  = wa_afvc-lifnr
              importing
                output = wa_afvc-lifnr.
*        call function 'CONVERSION_EXIT_ALPHA_INPUT'
*          exporting
*            input  = wa_afvc-matkl
*          importing
*            output = wa_afvc-matkl.

            ls_operation-matl_group = wa_afvc-matkl.
            ls_operation-purch_org = wa_afvc-ekorg.
            ls_operation-pur_group = wa_afvc-ekgrp.
            ls_operation-preq_name = wa_afvc-afnam.
            ls_operation-gr_rcpt = wa_afvc-wempf.
            ls_operation-vendor_no = wa_afvc-lifnr.
            ls_operation-unload_pt = wa_afvc-ablad.
            ls_operation-trackingno = wa_afvc-bednr.
            ls_operation-cost_element = wa_afvc-sakto.
          endif.
          if wa_afvc-ktsch is not initial.
            ls_operation-standard_text_key = wa_afvc-ktsch.
            ls_operation_x-standard_text_key = 'X'.
          endif.
          append ls_operation to operation.

          ls_operation_x-description = 'X'.
          ls_operation_x-plant           = 'X'.
          ls_operation_x-control_key     = 'X'.
          ls_operation_x-duration_normal = 'X'.
          ls_operation_x-number_of_capacities = 'X'.
          ls_operation_x-work_activity   = 'X'.
          ls_operation_x-calc_key        = 'X'.
          ls_operation_x-work_cntr       = 'X'.
          ls_operation_x-activity        = 'X'.
          ls_operation_x-duration_normal_unit = 'X'.
          ls_operation_x-un_work         = 'X'.
          ls_operation_x-description     = 'X'.
          ls_operation_x-funct_loc       = 'X'.
          ls_operation_x-usr00 = 'X'.
          ls_operation_x-usr01 = 'X'.
          ls_operation_x-usr02 = 'X'.
          ls_operation_x-usr09 = 'X'.

          if wa_afvc-steus = 'PM02'.
            ls_operation_x-matl_group = 'X'.
            ls_operation_x-purch_org = 'X'.
            ls_operation_x-pur_group = 'X'.
            ls_operation_x-preq_name = 'X'.
            ls_operation_x-gr_rcpt = 'X'.
            ls_operation_x-vendor_no = 'X'.
            ls_operation_x-unload_pt = 'X'.
            ls_operation_x-trackingno = 'X'.
            ls_operation_x-cost_element = 'X'.
          endif.
          append ls_operation_x to  operation_up.

*         Operation Long Text
          if wa_afvc-text is initial.
            wa_afvc-text = wa_afvc-ltxa1.
          endif.

          refresh text_lines_tab.
          text_lines_tab = prepare_long_text( wa_afvc-text ).

          clear wa_text.
          describe table text_lines lines ln1.
          wa_text-textstart = ln1 + 1.

          append lines of text_lines_tab to text_lines.
          describe table text_lines lines ln1.
          wa_text-orderid = wa_afvc-aufnr.
          wa_text-activity = wa_afvc-vornr.
          wa_text-textend = ln1.
          append wa_text to text.

          clear wa_methods.
          lv_textref = lv_textref + 1.
          wa_methods-refnumber = lv_textref.
          wa_methods-method = 'CHANGE'.
          wa_methods-objecttype = 'TEXT'.
          concatenate wa_afvc-aufnr wa_afvc-vornr into wa_methods-objectkey in character mode.
          append wa_methods to methods.

*      Update User Status
          if wa_afvc-esth = 'X'.
            concatenate wa_afvc-usrst 'ESTH' into wa_afvc-usrst separated by space.
          endif.

          if wa_afvc-detc = 'X'.
            concatenate wa_afvc-usrst 'DETC' into wa_afvc-usrst separated by space.
          endif.
          if wa_afvc-prto = 'X'.
            concatenate wa_afvc-usrst 'PRTO' into wa_afvc-usrst separated by space.
          endif.
          if wa_afvc-jbpk = 'X'.
            concatenate wa_afvc-usrst 'JBPK' into wa_afvc-usrst separated by space.
          endif.
          if wa_afvc-npln = 'X'.
            concatenate wa_afvc-usrst 'NPLN' into wa_afvc-usrst separated by space.
          endif.

          if wa_afvc-usrst ne space.
            split wa_afvc-usrst at space into table lt_user.
            sort lt_user.
            delete lt_user where user = space.
            delete adjacent duplicates from lt_user comparing all fields.
            if lv_useref is initial.
              lv_useref = '000001'.
            endif.
*        check if status is already active in the system
            if wa_afvc-objnr ne space.
              clear : stxt,
                usr_stxt.
              call function 'STATUS_TEXT_EDIT'
                exporting
                  objnr            = wa_afvc-objnr
                  spras            = sy-langu
                  flg_user_stat    = 'X'
                importing
                  e_stsma          = stxt
                  user_line        = usr_stxt
                exceptions
                  object_not_found = 1
                  others           = 2.
            endif.
            loop at lt_user into lw_user.
              if usr_stxt cs lw_user-user.
                if ( lw_user-user = 'ESTH' and wa_afvc-esth = 'X' ) or
                   ( lw_user-user = 'DETC' and wa_afvc-detc = 'X' ) or
                   ( lw_user-user = 'PRTO' and wa_afvc-prto = 'X' ) or
                   ( lw_user-user = 'JBPK' and wa_afvc-jbpk = 'X' ) or
                   ( lw_user-user = 'NPLN' and wa_afvc-npln = 'X' ).
                  continue.
                endif.
              endif.
              userstat-user_st_text = lw_user-user.
              userstat-langu = sy-langu.
              userstat-inactive = ' '.
              if ( lw_user-user = 'ESTH' and wa_afvc-esth is initial ).
                userstat-inactive = 'X'.
              endif.
              if ( lw_user-user = 'DETC' and wa_afvc-detc is initial ).
                userstat-inactive = 'X'.
              endif.
              if ( lw_user-user = 'PRTO' and wa_afvc-prto is initial ).
                userstat-inactive = 'X'.
              endif.
              if ( lw_user-user = 'JBPK' and wa_afvc-jbpk is initial ).
                userstat-inactive = 'X'.
              endif.
              if ( lw_user-user = 'NPLN' and wa_afvc-npln is initial ).
                userstat-inactive = 'X'.
              endif.
              append userstat to userstatus.
              wa_methods-refnumber = lv_useref.
              wa_methods-objecttype = 'USERSTATUS'.
              wa_methods-method = 'CHANGE'.
              wa_methods-objectkey = wa_afvc-aufnr && wa_afvc-vornr.
              append wa_methods to methods.
              lv_useref = lv_useref + 1.
            endloop.

          endif.

        endloop.

        clear : ln1.
        loop at gt_resb1 into wa_resb where text ne space and rsnum is initial.
          select single rsnum from resb into wa_resb-rsnum
                               where aufnr = gv_ord_detail-aufnr.

          refresh text_lines_tab.
          text_lines_tab = prepare_long_text( wa_resb-text ).

          clear wa_text.
          describe table text_lines lines ln1.
          wa_text-textstart = ln1 + 1.

          append lines of text_lines_tab to text_lines.
          describe table text_lines lines ln1.

          wa_text-orderid = wa_resb-aufnr.
          wa_text-activity = wa_resb-posnr.
          wa_text-reserv_no = wa_resb-rsnum.
          wa_text-res_item = wa_resb-rspos.
          wa_text-textend = ln1.
          append wa_text to text.

          lv_textref = lv_textref + 1.
          wa_methods-refnumber = lv_textref.
          wa_methods-method = 'CHANGE'.
          wa_methods-objecttype = 'TEXT'.
          concatenate wa_resb-aufnr wa_resb-rspos into wa_methods-objectkey in character mode.
          append wa_methods to methods.
        endloop.
*        save data
        call function 'BAPI_ALM_ORDER_MAINTAIN'
          tables
            it_methods      = methods
            it_operation    = operation
            it_operation_up = operation_up
            it_text         = text
            it_text_lines   = text_lines
            return          = return.
        if sy-subrc eq 0.
          read table return into ls_return with key type = 'E'.
          if sy-subrc ne 0.
            call function 'BAPI_TRANSACTION_COMMIT'
              exporting
                wait = 'X'.
          endif.
        endif.
      endif.
*    create tasklist
      if gt_createtl[] is not initial.
        create_tasklist( gv_ord_detail-aufnr ).
      endif.

    endif.

* Get the Logon Langu
    call function 'TH_LONG_USR_INFO'
*         EXPORTING
*           USER            = ' '
      tables
        user_info = lt_info.
    describe table lt_info lines ln.
    read table lt_info into wa_info index ln.
*    create message
    loop at return into ls_return where type = 'E'.
      call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
        exporting
          i_langu                 = wa_info-lang
          i_msgid                 = ls_return-id
          i_msgno                 = ls_return-number
          i_msgv1                 = ls_return-message_v1
          i_msgv2                 = ls_return-message_v2
          i_msgv3                 = ls_return-message_v3
          i_msgv4                 = ls_return-message_v4
        importing
          e_msg                   = ls_return-message
        tables
          et_return               = lt_return_msg
        exceptions
          msg_for_langu_not_found = 1
          others                  = 2.
      if sy-subrc <> 0.
* Implement suitable error handling here
      endif.

      wa_message-value = gv_ord_detail-aufnr.
      wa_message-message = ls_return-message.
      case ls_return-type.
        when 'E'.
          wa_message-mss_type = 'Error'.
        when 'W'.
          wa_message-mss_type = 'Warning'.
        when 'I'.
          wa_message-mss_type = 'Information'.
        when 'S'.
          wa_message-mss_type = 'Success'.
        when others.
          wa_message-mss_type = 'None'.
      endcase.

      append wa_message to gt_message.
      clear wa_message.
    endloop.
*    display one single sucess message
    if sy-subrc ne 0.
      ls_return-number = '000'.
      call function '/TDAG/CP_LB03N_MSG_TRANSLATE'
        exporting
          i_langu                 = wa_info-lang
          i_msgid                 = gv_message_id
          i_msgno                 = ls_return-number
        importing
          e_msg                   = ls_return-message
        tables
          et_return               = lt_return_msg
        exceptions
          msg_for_langu_not_found = 1
          others                  = 2.
      if sy-subrc <> 0.
* Implement suitable error handling here
      endif.
      wa_message-value = gv_ord_detail-aufnr.
      wa_message-message = ls_return-message.
      wa_message-mss_type = 'Success'.
      append wa_message to gt_message.
    endif.
*    endif.
*    Save attachments
    loop at gt_attachments into ls_attachment where not uuid is initial.
*     Remove attachments which have already been processed.
      read table lt_uuids with key table_line = ls_attachment-uuid
          transporting no fields.
      if sy-subrc = 0.
        delete gt_attachments.
        continue.
      endif.

      check not:
          ls_attachment-file_name is initial,
          ls_attachment-file_data is initial.

      refresh lt_gos_messages.
      clear lv_file_data.

      call function 'SCMS_BASE64_DECODE_STR'
        exporting
          input  = ls_attachment-file_data
        importing
          output = lv_file_data
        exceptions
          others = 1.

      ls_lporb-instid = gv_ord_detail-aufnr.
      ls_lporb-typeid = 'BUS2007'.

      lt_gos_messages = cl_fitv_gos=>save(
        iv_name        = ls_attachment-file_name
        iv_content_hex = lv_file_data
        is_lporb       = ls_lporb
        iv_objtp       = 'EXT'
      ).

      loop at lt_gos_messages into ls_gos_message where type = 'E'.
        clear wa_message.
        wa_message-message = gv_ord_detail-aufnr && ls_gos_message-message.
        wa_message-mss_type   = 'Error'.
        append wa_message to gt_message.
      endloop.
*
      if sy-subrc <> 0.
*       Store processed entries.
        clear ls_ypmnptrecpr.
        ls_ypmnptrecpr-object_type   = 'PLANNERS'.
        ls_ypmnptrecpr-object_number = gv_ord_detail-aufnr.
        ls_ypmnptrecpr-guid          = ls_attachment-uuid.
        ls_ypmnptrecpr-record_date   = ls_attachment-gendate.
        ls_ypmnptrecpr-record_table  = 'ATT'.
        insert ypmnptrecpr from ls_ypmnptrecpr.
      endif.
    endloop.
    if sy-subrc eq 0.
      commit work.
    endif.
*    Delete existing records from table
*    read table gt_sel_attach into wa_sel_attach
*            with key work_order = gv_ord_detail-aufnr.
    read table gt_attach_jobpkg into ls_attach_jobpkg
        with key work_order = gv_ord_detail-aufnr.
    if sy-subrc eq 0.
      delete from ypmnptjobpkg
                where work_order = gv_ord_detail-aufnr.
      if sy-subrc eq 0 .
        commit work.
      endif.
      clear : wa_sel_attach.
*    Save job package from attachments
      loop at gt_attach_jobpkg into ls_attach_jobpkg
          where work_order = gv_ord_detail-aufnr.
        move-corresponding ls_attach_jobpkg to ls_ypmnptjobpkg.
        insert ypmnptjobpkg from ls_ypmnptjobpkg.
      endloop.

*      loop at gt_sel_attach into wa_sel_attach
*                   where work_order = gv_ord_detail-aufnr.
**     Store job location data
*        move-corresponding wa_sel_attach to ls_ypmnptjobpkg.
**        ls_ypmnptjobpkg-work_order = gv_ord_detail-aufnr.
**        ls_ypmnptjobpkg-operation = wa_sel_attach-vornr.
**        ls_ypmnptjobpkg-instid_b = wa_sel_attach-instid_b.
*        insert ypmnptjobpkg from ls_ypmnptjobpkg.
*      endloop.
      commit work.
    endif.
  endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Protected Method YCL_PM_PLANNER_CLASS->SEARCH_MATERIAL_TEXT
* +-------------------------------------------------------------------------------------------------+
* +--------------------------------------------------------------------------------------</SIGNATURE>
method SEARCH_MATERIAL_TEXT.
  refresh gt_material_text.
  gt_material_text = ycl_pm_npt_utilities=>search_material_trex(
    iv_material = wa_trex_search-material
    iv_material_short_text = wa_trex_search-short_text
    iv_material_text = wa_trex_search-full_text
  ).
endmethod.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Instance Protected Method YCL_PM_PLANNER_CLASS->VALIDATE_MATERIAL
* +-------------------------------------------------------------------------------------------------+
* | [--->] IV_MATERIAL                    TYPE        MATNR
* | [--->] IV_PLANT                       TYPE        WERKS_D
* | [!CX!] YCX_NPT_EXCEPTIONS
* +--------------------------------------------------------------------------------------</SIGNATURE>
method VALIDATE_MATERIAL.
  data: lv_val_class type bklas,
        lv_material  type matnr.

  lv_material = iv_material.
  ycl_pm_npt_utilities=>conversion_in( changing cv_value = lv_material ).

* Check whether the valuation class of the material is valid.
  select single bklas into lv_val_class
      from mbew
      where matnr = lv_material
        and bwkey = iv_plant.

  if lv_val_class = '0018'.
    ycl_pm_npt_utilities=>conversion_out( changing cv_value = lv_material ).
    raise exception type ycx_npt_exceptions
      exporting
        material        = lv_material
        valuation_class = lv_val_class.
  endif.
endmethod.
ENDCLASS.